== Data Specification Templates (normative)

=== Introduction

A data specification template specifies which additional attributes, which are not part of the metamodel, shall be added to an element instance. Typically, data specification templates have a specific scope. For example, templates for concept descriptions differ from templates for operations, etc. More than one data specification template can be defined and used for an element instance. _HasDataSpecification_ defines, which templates are used for an element instance.

Figure 55 shows the concept of data specification for a predefined data specification conformant to IEC61360footnote:[Since the data specification templates are specified and maintained in separate documents, these templates are considered as examples only, although there is a similarity to existing data specifications.] that, for example, can be used for concept descriptions for single properties.

.Core Elements of Using Data Specifications (non-normative)
image::image56.png[]

The template introduced to describe the concept of a property, a value list, or a value is based on IEC 61360. Figure 55 also shows how concept descriptions and the predefined data specification templates are related to each other.

==== Data Specification Template Attributes

.Data Specification Templates
image::image57.png[]


====
Note: the data specification templates do not belong to the metamodel of the Asset Administration Shell. In serializations that choose specific templates, the corresponding data specification content may be directly incorporated.
====


It is required that a data specification template has a global unique ID so that it can be referenced via _HasDataSpecification/dataSpecification_.

A template consists of the _DataSpecificationContent_ containing the additional attributes to be added to the element instance that references the data specification template, as well as meta information about the template itself. These are two separate classes in UML.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[DataSpecification]]DataSpecification \<<Template>>
|Explanation: |Data specification template
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.

|idShort | name of the data specification |xref:NameType[NameType] |0..1

|description |Description of how and in which context the data specification template is applicable; can be provided in several languages. |xref:MultiLanguageTextType[MultiLanguageTextType] |0..1

|administration a|
Administrative information of an identifiable element


====
Note: some of the administrative information like the version number might need to be part of the identification.
====

|xref:AdministrativeInformation[AdministrativeInformation] |0..1

|id |The globally unique identification of the data specification

====
Note: This identifier is used as value for xref:HasDataSpecification[HasDataSpecification/dataSpecification] 
====

|xref:Identifier[Identifier] |1

|dataSpecificationContent |The content of the template without meta data
|xref:DataSpecificationContent[DataSpecificationContent] |1

|===

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[DataSpecificationContent]]DataSpecificationContent \<<Template>>\<<abstract>>
|Explanation: |Data specification content is part of a data specification template and defines, which additional attributes shall be added to the element instance that references the data specification template and meta information about the template itself.
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|===

== Mappings to Data Formats to Share I4.0-Compliant Information (normative)

=== General

It is crucial for Industry 4.0 applications to share information between different systems throughout the areas covered by the entire RAMI4.0 model link:#bib1[[1\]] link:#bib2[[2\]]. OPC UA is a frequently used format for information models in the domain of production operations, but there is a need for other formats for further areas and the relationships between them.

This document specifies the Asset Administration Shell in a technology-neutral format, UML. Different data formats are used or recommended to be used in the different life cycle phases of a productfootnote:[The word “data formats” is used as shortcut and includes the use of conceptual advantages such as information models, schemes, transmission protocols, etc.]. Serializations and mappings of the Asset Administration Shell are provided to cover the complete life cycle of each of these formats. Figure 57.

Table 10 explains the main purpose of each of the formats: OPC UA information modelsfootnote:[OPC UA Information Models should not be mixed up with the Client/Server or Pub/Sub Protocol of OPC UA. This would belong to the communication but not to the Asset Administration Shell representation layer.], AutomationML, XML, JSON, and RDF. The different purposes are visualized in Figure 57.

.Distinction of Different Data Formats for the Asset Administration Shell
[cols="21%,79%",options="header",]
|===
|Data format |Purpose / motivation
|XML, JSON |Serialization of information for the technical communication between phases
|RDF |Mapping of information to enable full use of the advantages of semantic technologies
|AutomationML |Sharing of type and instance information about assets, particularly during engineering; transfer of this information into the operational phase (cf. OPC UA and the corresponding mapping)
|OPC UA Information models |Access to all information of the administration data and sharing of live data within production operations; access for higher-level factory systems to this information
|===

.Graphic View on Exchange Data Formats for the Asset Administration Shellfootnote:[Only data formats considered in this document so far are mentioned in the figure.]
image::image58.jpeg[]


====
Note: the mapping specifications and schemata themselves are not part of the specification any longer but maintained open source. This eases usage of the specification and the different formats in open-source code projects.
====


===  General Rules

====  Introduction

There are some general rules that apply to all serializations or can be used in different serializations.

====  Encoding

Blobs require the following encoding: base64 string.

include::IDTA-01001_GrammarSerializationReference.adoc[] 


include::IDTA-01001_GrammarSemanticIdsMetamodel.adoc[]


====  Embedded Data Specifications

This specification predefines data specifications that can be used within an Asset Administration Shell to ensure interoperability.

Consequently, some serializations or mappings support exactly the data descriptions defined in this specification, although the metamodel as such is more flexible and would also support proprietary data specifications.

In the case of restricted use of data specifications, we speak of "embedded data specifications". Figure 58 explains the realization: instead of a set of external global references to externally defined data specifications, a set of pairs consisting of an external global reference to a data specification and the data specification content itself are directly "embedded". Here, the data specification content belongs to the schema, while the data specification including its content are not part of the schema in the general concept. This is similar to the concept of _semanticIds_: either it is an external global reference to an external concept dictionary, or it is a reference to a concept description within the schema. However, there is only one reference allowed for _semanticId_, whereas a set of data specification references is permitted for data specifications.

.Realization of Embedded Data Specifications
image::image59.png[]
