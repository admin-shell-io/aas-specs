////
Copyright (c) 2023 Industrial Digital Twin Association

This work is licensed under a [Creative Commons Attribution 4.0 International License](
https://creativecommons.org/licenses/by/4.0/). 

SPDX-License-Identifier: CC-BY-4.0

////

////
includes:

IDTA-01001_GrammarSerializationReference.adoc
IDTA-01001_EmbeddedDataSpecifications.adoc
IDTA-01001_MetaDataObjects.adoc
IDTA-01001_ValueOnly.adoc
IDTA-01001_idShortPath.adoc
////

:page-partial:

[[part1-mappings]]
= Mappings (normative)

== Technical Data Formats

It is crucial for Industry 4.0 applications to share information between different systems throughout the areas covered by the entire RAMI4.0 model xref:IDTA-01xxx_Bibliography.adoc#bib1[[1\]] xref:IDTA-01xxx_Bibliography.adoc#bib2[[2\]]. OPC UA is a frequently used format for information models in the domain of production operations, but there is a need for other formats for further areas and the relationships between them.

This document specifies the Asset Administration Shell in a technology-neutral format, UML. Different data formats are used or recommended to be used in the different life cycle phases of a productfootnote:[The word “data formats” is used as shortcut and includes the use of conceptual advantages such as information models, schemes, transmission protocols, etc.]. Serializations and mappings of the Asset Administration Shell are provided to cover the complete life cycle of each of these formats. Figure 57.

Table 10 explains the main purpose of each of the formats: OPC UA information modelsfootnote:[OPC UA Information Models should not be mixed up with the Client/Server or Pub/Sub Protocol of OPC UA. This would belong to the communication but not to the Asset Administration Shell representation layer.], AutomationML, XML, JSON, and RDF. The different purposes are visualized in Figure 57.

.Distinction of Different Data Formats for the Asset Administration Shell
[cols="21%,79%",options="header",]
|===
|Data format |Purpose / motivation
|XML, JSON |Serialization of information for the technical communication between phases
|RDF |Mapping of information to enable full use of the advantages of semantic technologies
|AutomationML |Sharing of type and instance information about assets, particularly during engineering; transfer of this information into the operational phase (cf. OPC UA and the corresponding mapping)
|OPC UA Information models |Access to all information of the administration data and sharing of live data within production operations; access for higher-level factory systems to this information
|===

.Graphic View on Exchange Data Formats for the Asset Administration Shellfootnote:[Only data formats considered in this document so far are mentioned in the figure.]
image::image58.jpeg[]


====
Note: the mapping specifications and schemata for XML, JSON and RDF are part of https://github.com/admin-shell-io/aas-specs. Handling of Asset Administration Shell and OPC UA and AutomationML is handled in separate joint working groups of the assocations and IDTA.
====


==  Content Format Types

For different use case scenarios different formats are suitable to fulfill the needs.
Besides technical formats like JSON and XML also different content formats are available.


.Format Types
[%autowidth, width="100%", cols="29%,71%",options="header",]
|===
|*Format* |*Explanation*
|Normal a|The standard serialization of the model element or child elements is applied.

|Metadata a|Only metadata of an element or child elements is returned; the value is not.

|Value a|Only the raw value of the model element or child elements is returned; it is commonly referred to as _ValueOnly_-serialization.

|Reference |Only applicable to Referables. Only the reference to the found element is returned; potential child elements are ignored.

|Path a|Returns the idShort of the requested element and a list of _idShort_ paths to child elements if the requested element is a Submodel, a SubmodelElementCollection, a SubmodelElementList, a AnnotatedRelationshipElement, or an Entity.
|===


==   Encoding

Blobs require the following encoding: base64 string.



include::./includes/IDTA-01001_GrammarSerializationReference.adoc[leveloffset=-1]

include::./includes/IDTA-01001_EmbeddedDataSpecifications.adoc[leveloffset=-1]

include::./includes/IDTA-01001_MetaDataObjects.adoc[leveloffset=-1]

include::./includes/IDTA-01001_ValueOnly.adoc[leveloffset=-1]

include::./includes/IDTA-01001_idShortPath.adoc[leveloffset=-1]

==  Format "Reference"

In some use cases only the (model) reference to the object is needed in the first place.

References are possible for Referables, only. Potential child elements are ignored.

For references see Clause xref:#_referencing_in_asset_administration_shells[].

.Format "Reference" - Example in JSON
[source,json,linenums]
----
      {
        "keys": [
          {
            "type": "AssetAdministrationShell",
            "value": "urn:an-example08:f3f73640"
          }
        ],
        "type": "ModelReference"
      }

----

==  Format "Normal" in  XML

The metamodel of an Asset Administration Shell needs to be serialized for import and export scenarios. XML is a possible serialization format.

eXtensible Markup Language (XMLfootnote:[see: https://www.w3.org/TR/2008/REC-xml-20081126/]) is very well suited to derive information from an IT system, e.g. to process it manually and then feed it into another IT system. It meets the needs of the information sharing scenario defined in the leading picture in Clause 4.1. XML provides the possibilities of scheme definitions, which can be used to syntactically validate the represented information in each step.


====
Note 1: the xml schema (.xsd files) is maintained in the repository "aas-specs" of the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]] in folder `schemas\xml`
====



====
Note 2: the mapping rules of how to derive the xml schema from the technology-neutral metamodel as defined in this specification can be found in the repository "aas-specs" of the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]] in folder `schemas\xml\Readme.md#xml-mappingrules`
====



====
Note 3: example files can be found in the repository “aas-specs” in the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]]  in folder : `schemas\xml\examples`
====


==   Format "Normal" in JSON

JSONfootnote:[see: https://tools.ietf.org/html/rfc8259 or https://www.ecma-international.org/publications/standards/Ecma-404.htm] (JavaScript Object Notation) is a further serialization format that serializes the metamodel of an Asset Administration Shell for import and export scenarios.

Additionally, JSON format is used to describe the payload in the http/REST API for active Asset Administration Shells xref:IDTA-01xxx_Bibliography.adoc#bib37[[37\]].


====
Note 1: the JSON schema (.json files) is maintained in the repository "aas-specs" of the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]] in folder `schemas\json`
====



====
Note 2: the mapping rules of how to derive the JSON schema from the technology-neutral metamodel as defined in this specification can be found in the repository "aas-specs" of the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\] in `schemas\json\Readme.md#json-mappingrules`
====



====
Note 3: example files can be found in the repository "aas-specs"  in the github project admin-shell-io [xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]  in folder `schemas\json\examples`
====


==   Format "Normal" in RDF

The Resource Description Framework (RDF) xref:IDTA-01xxx_Bibliography.adoc#bib32[[32\]] is the recommended standard of the W3C to unambiguously model and present semantic data. RDF documents are structured in the form of triples, consisting of subjects, relations, and objects. The resulting model is often interpreted as a graph, with the subject and object elements as the nodes and the relations as the graph edges.

RDF is closely related to web standards, illustrated by the fact that all elements are encoded using (HTTP-)IRIs. As a common practice, the provision of additional information at the referenced location of an RDF entity directly allows the interlinking of entitiesfootnote:[Note: entity as a generic term and entity as a specific submodel element subtype need tobe distinugished.] based on the web. This process – following links in order to discover related information – is called dereferencing a resource and is supported by any browser or web client. Connecting distributed data sources through the web in the described manner is referred to by the term “Linked Data”. Connecting the available resources and capabilities of linked data with the expressiveness of the Asset Administration Shell is one motivation for the RDF serialization.

In addition, RDF is the basis of a wide range of logical inference and reasoning techniques. Vocabularies like RDF Schema (RDFS) and the Web Ontology Language (OWL) combine the graph-based syntax of RDF with formal definitions and axioms. This allows automated reasoners to understand the relation between entities to some extent and draw conclusions.

Combining both features, the RDF mapping of the Asset Administration Shell can provide the basis for complex queries and requests. SPARQL, the standard query language for the Semantic Web, can combine reasoning features with the integration of external data sources. In order to benefit of these abilities, the Asset Administration Shell requires a clear scheme of its RDF representation.


====
Note 1: the RDF scheme/OWL files (.ttl files) are maintained in the repository "aas-specs" of the github project admin-shell-io xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\]] in folder `schemas\rdf`
====



====
Note 2: the mapping rules of how to derive the RDF schema from the technology-neutral metamodel as defined in this specification can be found in the repository "aas-specs"  of the github project admin-shell-io [xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\] in `schemas\rdf\Readme.md#rdf-mappingrules`
====



====
Note 3: example files can be found n the repository "aas-specs"  of the github project admin-shell-io [xref:IDTA-01xxx_Bibliography.adoc#bib51[[51\] in folder `schemas\rdf\examples`
====

