////
Copyright (c) 2023 Industrial Digital Twin Association

This work is licensed under a [Creative Commons Attribution 4.0 International License](
https://creativecommons.org/licenses/by/4.0/).

SPDX-License-Identifier: CC-BY-4.0

Illustrations:
Plattform Industrie 4.0; Anna Salari, Publik. Agentur für Kommunikation GmbH, designed by Publik. Agentur für Kommunikation GmbH
////

////
includes events.adoc
////
[[part1-general]]
= General

== Introduction

Before specifying the information metamodel of the Asset Administration Shell, some general topics relevant for the Asset Administration Shell are explained.

Subclause xref:general.adoc#types-and-instances[Types and Instances] describes some general aspects of handling type and instance assets.

Subclause xref:general.adoc#identification-of-elements[Identification of Elements] explains the very important aspects of identification in the context of the Asset Administration Shell.

Subclause xref:general.adoc#matching-strategies[Matching Strategies] provides matching strategies for semantic identifiers and references.

Subclause xref:general.adoc#submodel-instances-and-templates[Submodel Instances and Templates] explains the difference between submodel instances and templates.

Subclause xref:general.adoc#events[Events] discusses aspects of event handling.

[#types-and-instances]
== Types and Instances

=== Life Cycle with Type Assets and Instance Assets

Industry 4.0 utilizes an extended understanding of assets, comprising elements such as factories, production systems, equipment, machines, components, produced products and raw materials, business processes and orders, immaterial assets (such as processes, software, documents, plans, intellectual property, standards), services, human personnel, etc..

The RAMI4.0 model xref:bibliography.adoc#bib3[[3\]] defines a generalized life cycle concept derived from IEC 62890.
The basic idea is to distinguish between possible types and instances for all assets within Industry 4.0.
This makes it possible to apply the type/instance distinction for all elements such as material type/material instance, product type/product instance, machine type/ machine instance, etc.
Business-related information is handled on the 'business' layer of the RAMI4.0 model.
The business layer also covers order details and workflows, again for both type and instance assets.

====
Note: to distinguish asset 'type' and asset 'instance', the term 'asset kind' is used in this document.
The three different relationship classes between assets, especially type assets and instance assets, explained below show why the distinction is so important.
The attribute "derivedFrom" in the metamodel is used to explicitly state a relationship between assets that are being derived from one another.
Other relationships are not explicitly supported by the metamodel of the Asset Administration Shell, but they can be modelled via the xref:spec-metamodel/submodel-elements.adoc#relationship-element-attributes["RelationshipElement"] submodel element type.
====

Table <<table-life-cycle-phases-and-roles-of-type-and-instance-assets>> gives an overview of the different life cycle phases and the role of type assets and instance assets as well as their relationship in these phases.

This important relationship should be maintained throughout the life of the instance assets.
It makes it possible to forward updates from the type assets to the instance assets, either automatically or on demand.

.Life Cycle Phases and Roles of Type and Instance Assets
[[table-life-cycle-phases-and-roles-of-type-and-instance-assets]]
[cols="20%,22%,58%",options=header]
|===
|*Asset Kind* |*Life Cycle Phase* |*Description*
|Type asset |Development a|
Valid from the ideation/conceptualization to the first prototypes/test.
The 'type' of an asset is defined; distinguishing properties and functionalities are defined and implemented.
All (internal) design artefacts associated with the type asset are created, such as CAD data, schematics, embedded software.

| |Usage/ +
Maintenance a|
Ramping up production capacity.
The 'external' information associated to the asset is created, such as technical data sheets, marketing information.
The selling process starts.

|Instance asset |Production a|
Instance assets are created/produced, based on the type asset information.
Specific information about production, logistics, qualification, and test are associated with the instance assets.

| |Usage/ +
Maintenance a|
Usage phase by the purchaser of the instance assets.
Usage data is associated with the instance asset and might be shared with other value chain partners, such as the manufacturer of the instance asset.

Also included: maintenance, re-design, optimization, and de-commissioning of the instance asset.
The full life cycle history is associated with the asset and might be archived/shared for documentation.

|===

The second class of relationships are feedback loops/information within the life cycle of the type asset and instance asset.
For product assets, for example, information on usage and maintenance of product instances may be used to improve product manufacturing as well as the design of the (next) product type.

The third class of relationships are feedforward/information exchange with assets of other asset classes.
For example, sourcing information from business assets can influence design aspects of products; or the design of the products affects the design of the manufacturing line.

====
Note: the NIST model xref:bibliography.adoc#bib49[[49\]] provides an illustration of the second/third class of relationships.
====

A fourth class of relationships consists between assets of different hierarchy levels.
For example, these could be the (dynamic) relationships between manufacturing stations and currently produced products.
They could be also the decomposition of production systems in physical, functional, or safety hierarchies.
In this class of relationships, automation equipment is seen as a complex, interrelated graph of automation devices and products, performing intelligent production and self-learning/optimization tasks.

Details and examples for composite I4.0 Components can be found in xref:bibliography.adoc#bib12[[12\]].
A composite I4.0 Component is the combination of a complex asset and its Asset Administration Shell.
The hierarchy, typically a Bill of Material (BOM) but also any other relationship between different assets, can be represented in one of its submodels.

====
Note: for submodels representing the Bill of Material of a complex asset, the metamodel not only provides the possibility to define relationships (via the submodel element xref:spec-metamodel/submodel-elements.adoc#relationship-element-attributes[RelationshipElement], see above), it also explicitly supports the representation of another asset (via the submodel element "Entity").
The term "Entity" is chosen as superordinate concept in this context and refers to either an asset or another item that is not an asset but may be part of a more complex item or asset.
====

===  Asset Administration Shells Representing Type Assets and Instance Assets

An Asset Administration Shell either represents a type asset or an instance asset.
Typically, there is a relationship between instance assets and a type asset.
However, not every instance asset is required to have a corresponding type asset.

<<image-4-aas-type-instance>> gives an example of how to handle type assets and their derived instance assets.
The attribute "assetKind" indicates whether the Asset Administration Shell (denoted by the ": AAS" UML notation for a class instance) represents a type asset or an instance asset.
Additionally, attributes are added to show that the attributes of type asset and instance assets typically differ from each other.

.Example: Asset Administration Shells for Type and Instance Assets
[[image-4-aas-type-instance]]
[plantuml, image-4-aas-type-instance, svg]
....
include::partial$diagrams/4-aas-type-instance.puml[]
....


====
Note 1: the example is simplified for ease of understanding and only roughly complies with the metamodel as specified in Clause xref:spec-metamodel/nav-spec.adoc[].
The ID handling is simplified as well: the names of the classes correspond to the unique global identifier of the Asset Administration Shells.
====

====
Note 2: in the context of Plattform Industrie 4.0, types and instances typically refer to "type assets" and "instance assets".
When referring to types or instances of an Asset Administration Shell, this is explicitly denoted as "Asset Administration Shell types" and "Asset Administration Shell instances" to not mix them up.
Asset Administration Shell types are synonymously used with the term "Asset Administration Shell template".
====

====
Note 3: please refer to Clause xref:terms-definitions-and-abbreviations.adoc#terms-and-definitions[Terms and Definitions] for the IEC definition of types and instances.
Within the scope of this document, there is no full equivalency between these definitions and the type/instance concepts of object-oriented programming (OO).
====

There shall be a concrete type asset of a temperature sensor and two uniquely identifiable physical temperature sensors of this type.
The intention is to provide a separate Asset Administration Shell for the type asset as well as for every single instance asset.

In the example, the first sensor has the unique ID "0215551AAA_T1" and the second sensor has the unique ID "0215551AAA_T2".
"0215551AAA_T1" and "0215551AAA_T2" are the global asset IDs of the two assets, i.e. sensors.
The Asset Administration Shell for the first sensor has the unique URI "http://T1.com" and the Asset Administration Shell for the second sensor has the unique URI "http://T2.com".
The asset kind of both is "Instance".
The example shows that the measured temperature at operation time of the two sensors is different: for T1 it is 60 °C, for T2 it is 100 °C.
For the time-being we ignore the relationship "derivedFrom" of the two Asset Administration Shells "http://T1.com " and "http://T2.com" with Asset Administration Shell "http://T0215551AA.com".

====
Note 1: even though the HTTP scheme is used for the identifier, please be aware that these identifiers are logical ones.
Identifiers do not have to be URLs.
At the same time, URLs used as identifiers do not have to refer to accessible content.
====

====
Note 2: the physical unit can be obtained by the semantic reference of the element "measuredTemperature".
This is not shown in the example for simplicity reasons.
====

These two instance assets share a lot of information on the type asset (in this example a sensor type), for which an own Asset Administration Shell is created.
The unique ID for this Asset Administration Shell is "http://T0215551AA.com", the unique ID of the sensor type is "0215551AA".
The asset kind is "Type" and not "Instance".
The information shared by all instances of this temperature sensor type is the product class (="Component"), the manufacturer (="ExampleManufacturer"), the English Description (="precise and fast temperature measurement"), and the value range ("-40 °C / 140 °C").

Now the two Asset Administration Shells of the two instance assets may refer to the Asset Administration Shell of the type asset "0215551AA" using the relationship attribute "derivedFrom".

====
Note 1: in the UML sense, "attribute" refers to the property or characteristic of a class (instance).
====

====
Note 2: if a specific type asset exists, it typically exists in time before the respective instance assets.
====

====
Note 3: the term Asset Administration Shell is used synonymously with the term Asset Administration Shell instance.
An Asset Administration Shell may be realized based on an Asset Administration Shell type.
Asset Administration Shell types are out of the scope of this document.
====

====
Note 4: in public standardization, the Asset Administration Shell types might be standardized.
However, it is much more important to standardize the property types (called property definitions or concept descriptions) or other submodel element types as well as complete submodel types because these can be reused in different Asset Administration Shells.
====

====
Note 5: in the domain of the Internet of Things (IoT), instance assets are typically denoted as "Things" whereas type assets are denoted as "Product".
====

===  Asset Administration Shell Types and Instances

In the previous clause, type assets and instance assets were explained.
The obvious question now is how to harmonize Asset Administration Shells and Asset Administration Shell types.
The example in <<image-5-aas-types-and-instances>> shows that the attributes "globalAssetId" and "assetKind" as well as the global Asset Administration Shell identifier (_id_, represented as name of the class) are present for all Asset Administration Shells.
However, if there is no standard, the semantics of "id", "globalAssetId" or "kind" are not clear, although they are the same for all Asset Administration Shells.
It is also not clear, which of the attributes are mandatory and which are specific for the asset (type or instance), as illustrated in <<image-5-aas-types-and-instances>>.

This is the purpose of this document: the definition of a metamodel that defines which attributes are mandatory and which are optional for all Asset Administration Shells.
The Plattform Industrie 4.0 metamodel for Asset Administration Shells is defined in Clause xref:spec-metamodel/nav-spec.adoc#part1-specification[Specification].

====
Note 1: the metamodel of the Asset Administration Shell is suitable for type assets or instance assets.
An alternative approach could have been to define two metamodels, one for type assets and one for instance assets.
However, the large set of similarities led to the decision of only one metamodel.
====

====
Note 2: the metamodel itself does not require the existence of mandatory submodels.
This is another step of standardization similar to the standardization of submodels of the Asset Administration Shell type level.
====

====
Note 3: an Asset Administration Shell type shall be realized based on the metamodel of an Asset Administration Shell as defined in this document.
This metamodel is referred to as "Asset Administration Shell Metamodel".
====

====
Note 4: it is not mandatory to define an Asset Administration Shell type before defining an Asset Administration Shell (instance).
An Asset Administration Shell instance that does not realize an Asset Administration Shell type shall be realized based on the metamodel of an Asset Administration Shell as defined in this document.
====

.Example: Asset Administration Shell, Asset Administration Shell Types and Instances
[[image-5-aas-types-and-instances]]
[plantuml, image-5-aas-types-and-instances, svg]
....
include::partial$diagrams/5-aas-types-and-instances.puml[]
....


[#identification-of-elements]
== Identification of Elements

===  Overview

According to xref:bibliography.adoc#bib4[[4\]], identifiers are needed for the unique identification of many different elements within the domain of smart manufacturing.
They are a fundamental element of a formal description of the Administration Shell.
Identification is especially required for

* Asset Administration Shells,
* assets,
* submodel instances and submodel templates,
* property definitions/concept descriptions in external repositories, such as ECLASS or IEC CDD.

Identification will take place for two purposes

* to uniquely distinguish all elements of an Administration Shell and the asset it is representing, and
* to relate elements to external definitions, such as submodel templates and property definitions, in order to bind semantics to this data and the functional elements of an Administration Shell.

=== Identifiers for Assets and Administration Shells

In the domain of smart manufacturing, the assets need to be uniquely identified worldwide xref:bibliography.adoc#bib4[[4\]] xref:bibliography.adoc#bib20[[20\]] by the means of identifiers (IDs).
The Administration Shell also has a unique ID (see <<image-unique-identifier-for-aas-and-asset>>).

.Unique Identifier for Administration Shell and Asset (Modified Figure from xref:bibliography.adoc#bib4[[4\]])
[[image-unique-identifier-for-aas-and-asset]]
image::6-unique-identifier-for-aas-and-asset.jpeg[]

An Administration Shell represents exactly one asset, with a unique asset ID.
In a batch-based production, the batches will become the assets and will be described by a respective Administration Shell.
If a set of assets shall be described by an Administration Shell, a unique ID for the composite asset needs to be created xref:bibliography.adoc#bib13[[13\]].

The ID of the asset needs to comply with the restrictions for global identifiers according to xref:bibliography.adoc#bib4[[4\]]xref:bibliography.adoc#bib20[[20\]].
If the asset features further identifications like serial numbers and alike, they are not to be confused with the unique global identifiers of the asset itselffootnote:[Such additional asset identifiers are contained in _AssetInformation/specificAssetIds_.].

=== What Type of Identifiers Exist?

In xref:bibliography.adoc#bib4[[4\]]xref:bibliography.adoc#bib20[[20\]], two standard-conforming global identification types are defined:

* *IRDI* – ISO29002-5, ISO IEC 6523 and ISO IEC 11179-6 xref:bibliography.adoc#bib20[[20\]] as an identifier scheme for properties and classifications.
They are created in a process of consortium-wise specification or international standardization.
To this end, users come together and feed their ideas into the consortia or standardization bodies.
Properties in ISO, IEC help to safeguard key commercial interests.
Repositories like ECLASS and others make it possible to standardize a relatively large number of identifiers in an appropriately short time.
* *IRI* – IRI (link:https://tools.ietf.org/html/rfc3987[RFC 3987]) or URI and URL according to link:https://tools.ietf.org/html/rfc3986[RFC 3986] as identification of assets, Administration Shells and other (probably not standardized, but globally unique) properties and classifications.

The following is also permitted:

* *Custom* – internal custom identifiers such as UUIDs/GUIDs (link:https://en.wikipedia.org/wiki/Universally_unique_identifier[universally unique identifiers]/globally unique identifiers), which a manufacturer can use for all sorts of in-house purposes within the Administration Shell.

This means that the IRIs/URIs/URLs and internal custom identifiers can represent and communicate manufacturer-specific information and functions in the Administration Shell and the 4.0 infrastructure just as well as standardized information and functions.
One infrastructure can serve both purposes.

CLSID are URIs for GUIDs.
They start with a customer specific schema.
Hence, Custom should really only be used if the customer-specific identifier is no IRDI nor IRI.

Besides the global identifiers, there are also identifiers that are unique only within a defined namespace, typically its parent element.
These identifiers are also called local identifiers.
For example, properties within a submodel have local identifiers.

Besides absolute URIs there are also relative URIs.

See also DIN SPEC 91406 xref:bibliography.adoc#bib31[[31\]] for further information on identification.

[#which-identifiers-for-which-elements]
===  Which Identifiers for Which Elements?

Not every identifier is applicable for every element of the UML model representing the Asset Administration Shell.
Table <<table-elements-with-allowed-identifying-values>> therefore gives an overview on the different constraints and recommendations on the various entities, which implement xref:spec-metamodel/common.adoc#identifiable-attributes[Identifiable] or xref:spec-metamodel/common.adoc#has-semantics-attributes[HasSemantics].

See Annex xref:annex/concepts-aas.adoc#how-are-new-identifiers-created[How Are New Identifiers Created?] for more information on how to create new identifiers and best practices for creating URI identifiers.

.Elements with Allowed Identifying Values
[[table-elements-with-allowed-identifying-values]]
[cols="21%,17%,22%,40%",options="header",]
|===
|*Elements with identifying values* |*Attribute* |*Allowed identifiers (recommended or typical)* |*Remarks*
|xref:spec-metamodel/core.adoc#AssetAdministrationShell[AssetAdministrationShell] |id |IRI (URL) a|
mandatory

Typically, URLs will be used.

| |idShort |string |optionalfootnote:[Note: in version V1.0 of this specification, idShort was optional for identifiables. This changed in V2.0: idShort was set to mandatory for all referables. With V3.0, idShort was again made optional.]
| |displayName |multi language string |optional
|xref:spec-metamodel/core.adoc#AssetInformation[AssetInformation] |globalAssetId |IRI a|
recommended

As soon as the Asset Administration Shell is "released" for production or operation, a globalAssetId should be assigned.

An Asset ID may be retrieved e.g., by a QR code on the asset, by an RFID for the asset, from the firmware of the asset, or from an asset database.
IEC 61406 (formerly DIN SPEC 91406) defines the format of such Asset IDs.

| |specificAssetId |IRI, Custom a|
recommended

An asset typically may be represented by several different identification properties like for example the serial number, its RFID code etc.

They are used for lookup of Asset Administration Shells in cases the globalAssetId is not available.
However, they do not need to be globally unique.

|xref:spec-metamodel/core.adoc#Submodel[Submodel] with kind = Template |id |IRDI, IRI (URI) a|
mandatory

IRDI, if the defined submodel is standardized and has been assigned an IRDI.

| |idShort |string a|
recommended

Typically used as idShort for the submodel of kind Instance as well

| |displayName |multi language string a|
recommended

Typically used as displayName for the submodel of kind Instance as well

| |semanticId |IRDI, IRI (URI) a|
recommended

The semantic ID might refer to an external semantic model defining the semantics of the submodel.

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:spec-metamodel/core.adoc#Submodel[Submodel] with kind = Instance |id |IRI (URI), Custom |mandatory
| |idShort |string a|
recommended

Typically, the idShort or English short name of the submodel template that is referenced via semanticId.

| |displayName |multi language string |optional
| |semanticId |IRDI, IRI (URI) a|
recommended

Typically, the semanticId is an external reference to an external standard defining the semantics of the submodel.

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:spec-metamodel/core.adoc#SubmodelElement[SubmodelElement] |idShort |string a|
mandatory

Typically, the English short name of the concept definition that is referenced via semanticId.

| |displayName |multi language string a|
optional

If no display name is defined in the language requested by the application, the display name may be selected in the following order, if available:

* the preferred name in the requested language of the concept description defining the semantics of the element,
* if there is a default language list defined in the application, the corresponding preferred name in the language is chosen according to this order,
* the English preferred name of the concept description defining the semantics of the element,
* the short name of the concept description,
* the idShort of the element.

| |semanticId |IRDI, IRI (URI), Custom a|
recommended

link to a _ConceptDescription_ or the concept definition in an external repository via a global ID

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:spec-metamodel/concept-description.adoc#ConceptDescription[ConceptDescription] |id |IRDI, IRI, Custom a|
mandatory

_ConceptDescription_ needs to have a global ID.
If the concept description is a copy from an external dictionary like ECLASS or IEC CDD, it may use the same global ID as it is used in the external dictionary.

| |idShort |string a|
recommended

e.g. same as English short name

| |displayName |multi language string |optional
| |isCaseOf |IRDI, IRI (URI) a|
optional

links to the concept definition in an external repository, which the concept description is a copy from, or that it corresponds to

|xref:spec-metamodel/common.adoc#Qualifier[Qualifier] |semanticId |IRDI, IRI (URI), Custom a|
recommended

Links to the qualifier type definition in an external repository

IRDI, if the defined qualifier type is standardized and has been assigned an IRDI.

|===

=== Usage of Short ID for Identifiable Elements

The Administration Shell fosters the use of worldwide unique identifiers to a large degree.
However, in some cases, this may lead to inefficiencies.
Example: a property, which is part of a submodel, which in turn is part of an Administration Shell, each of which is identified by global identifiers xref:bibliography.adoc#bib4[[4\]].

In an application featuring a resource-oriented architecture (ROA), a worldwide unique resource locator (URL) might be composed of a series of segments, which do not need to be globally unique, see <<image-motiviation-of-exemplary-identifiers-and-idshort>>.

.Motivation of Exemplary Identifiers and idShort
[[image-motiviation-of-exemplary-identifiers-and-idshort]]
image::7-motiviation-of-exemplary-ids.jpeg[]

To allow such efficient addressing by the chaining of elements by an API of an Administration Shell, _idShort_ is provided for a set of classes of the metamodel.
It inherits from the abstract class xref:spec-metamodel/common.adoc#referable-attributes[Referable], in order to refer to such dependent elements.

Before accessing concrete data provided via a submodel, an application typically checks if the submodel provides the required data, i.e. the semantics of the submodel is checked for suitability.
A so-called _semanticId_ should be defined for this submodel as well as the submodel element.
This semantic ID helps to easily find the semantic definition of the submodel (see Clause xref:spec-metamodel/common.adoc#has-semantics-attributes[Has Semantics Attributes]).

[#matching-strategies]
== Matching Strategies

[#matching-strategies-for-semantic-identifiers]
=== Matching Strategies for Semantic Identifiers

When comparing two elements, different use cases should be considered in order to define how these two elements are semantically related.
This clause gives first hints on the aspects to consider when dealing with matching semantic identifiers.
For example, semantic references including context information as represented in IRDI-Path in ECLASS are not yet considered.
Sometimes a concept description is derived from another concept description or is identical to or at least compatible with another concept description.


*Exact Matching (identical semanticIds) – DEFAULT*

* With exact matching, two semantic IDs need to represent two exact matching references (see xref:general.adoc#matching-algorithm-for-references[Matching Algorithm for References]).
** Example: Property with idShort "ManufacturerName" + semanticId  value 0173-1#02-AAO677#002 and Property with idShort "Herstellername" + semanticId value 0173-1#02-AAO677#002 have exactly equal semantics if the key types in both semanticIds are identical as well plus the other attributes of a Reference like _referredSemanticId_. So if the first key type of property "ManufacturerName" is "ExternalReference" and the first key type of the semanticId of property  "Herstellername" is "ModelReference" then the two semanticIds are no exact match. Or if the first reference contains a referredSemanticId value and the second does not the two semantic IDs are not exact matches.

*Value Matching*

* With value matching, the key values of the two semantic IDs being compared need to be string-identical, i.e. the two references need to value match (see xref:general.adoc#matching-algorithm-for-references[Matching Algorithm for References]).
** Example: Property with idShort "ManufacturerName" + semanticId 0173-1#02-AAO677#002 and Property with idShort "Herstellername" + semanticId 0173-1#02-AAO677#002 have value equal semantics.


*Intelligent Matching (compatible semanticIds)*

Diffent kinds of intelligent matchind may be considered to be implemented. Some are explained in the following.

* Ignore Versioning
** With intelligent matching, different versions of a concept definition may be matched.
For example, if semantic versioning is used to version the concept description, then upward or backward compatible versions can be matched.
** Example: property with idShort "ManufacturerName" + semanticId 0173-1#02-AAO677#002 and Property with idShort "Herstellername" + semanticId 0173-1#02-AAO677#003 have equal semantics.

====
Note: to compare two semantic IDs, knowledge about versioning needs to be available.
In the example above, two IRDIs from ECLASS are compared.
ECLASS rules ensure that the semantics is always backward compatible for new versions; a new IRDI would be created for breaking changes.
====


* Consider different syntax of identifiers

** With intelligent matching, different syntax of the same identifier may be matched.
For example ECLASS allows to specify an identifier of a concept definition as IRDI or as URL.
ECLASS and IEC CDD both use IRDIs, however, the limiters are different.
** Example: \https://api.eclass-cdp.com/0173-1-02-AAC895-008
matches 0173-1#02-AAC895#008
** Example: 0173-1#02-AAC895#008 matches 0173/1///02#AAC895#008 

* Consider supplemental semantic IDs (any)

** With intelligent matching two sets of semantic IDs may be compared: Input is a set of semantic IDs, not distinguishing between semanticId and supplementalSemanticId. SupplementalSemanticIds are not ordered, so index information is not relevant. The input matches to an element for which either its semanticId is in the Input set of semantic IDs or one of its supplemental IDs matches to ones of the semantic IDs in the Input set.
** In addition exact or value matching of semantic IDs can be distinguished (see before)
** Example: Input Set = { 0173/1///02#AAC895#008} matches for a property with semanticId = \https://api.eclass-cdp.com/0173-1-02-AAC895-008 and supplementalSemanticId = 0173/1///02#AAC895#008.
** Example: Input Set = { 0173-1#02-AAC895#00, \https://api.eclass-cdp.com/0173-1-02-AAC895-008, 0173/1///02#AAC895#008 } would match for a property with semanticId = \https://api.eclass-cdp.com/0173-1-02-AAC895-008 and no supplemental semantic IDs.

* Consider supplemental semantic IDs (all)

** With intelligent matching two sets of semantic IDs may be compared: Input is a set of semantic IDs, not distinguishing between semanticId and supplementalSemanticId. SupplementalSemanticIds are not ordered, so index information is not relevant. The input matches to an element for which all the semantic IDS of the input set are available, either as semantic ID or as supplementalSemanticId. 
** In addition exact or value matching of semantic IDs can be distinguished (see before) 
** Example: Input Set = { 0173/1///02#AAC895#008} matches for a property with semanticId = \https://api.eclass-cdp.com/0173-1-02-AAC895-008 and supplementalSemanticId = 0173/1///02#AAC895#008.
** Example: Input Set = { 0173-1#02-AAC895#00, \https://api.eclass-cdp.com/0173-1-02-AAC895-008, 0173/1///02#AAC895#008 } does not match for a property with semanticId = \https://api.eclass-cdp.com/0173-1-02-AAC895-008 and no supplemental semantic IDs.

* Consider supplemental semantic IDs and isCaseOf

** The two intelligent matching strategies "Consider supplemental semantic IDs (any)" and "Consider supplemental semantic IDs (all)" may be extended to also include the isCaseOf information of a ConceptDescription referenced via one of the semantic IDs (semanticId or supplementalSemanticId) of an element.
** Example: Input Set = { 0173/1///02#AAC895#008} matches for a property with semanticId = [ModelRef](ConceptDescription) \https://admin-shell.io.example if the isCaseOf value of the referenced concept description with id =  \https://admin-shell.io.example is equal to 0173/1///02#AAC895#008.


* Consider Semantic Mappings
** Existing semantic mapping information can be considered for intelligent matching.
Semantic mappings may exist within one and the same dictionary, but also between different dictionaries and ontologies.
** Example: 0112/2///61360_4#AAE530 for nominal capacity of a battery in dictionary IEC CDD and 0173-1#02-AAI048#004 in ECLASS have equal semanticsfootnote:[Semantic mapping files are also used in ECLASS between ECLASS Classic and ECLASS Advanced: https://eclass.eu/support/technical-specification/data-model/basic-advanced-mapping] footnote:[This is the format used for semantic mapping in ECLASS: https://eclass.eu/fileadmin/Redaktion/pdf-Dateien/Wiki/ECLASSXML_3.0/ECLASS_XML/mapping.xsd].

====
Note: this example does not represent an existing semantic mapping; it is only a candidate.
====



* Consider Domain Knowledge
** With intelligent matching, domain knowledge available in machine-readable form may be taken into account, such as an "is-a"-relationship between two concept definitions.
** Example: a Hammer drill (0173-1#01-ADS698#010) and a percussion drill (0173-1#01-ADS700#010) are drills for mineral material (0173-1#01-ADN177#005) and are compatible with a request or constraints asking for drills for mineral material.




[#matching-algorithm-for-references]
=== Matching Algorithm for References

Clause 4.4.1 has discussed matching strategies for semantic identifiers.
This clause explains matching strategies based on the reference concept (see Clause xref:spec-metamodel/referencing.adoc#referencing-in-aas[Referencing]) in more detail and covers other kinds of identifying elements.

For example, the string serialization of references as defined in Clause xref:mappings.adoc#reference-serialization[Text Serialization of Values of Type "Reference"] is used for easier understanding.

====
Note: Matching in this context means supporting a discovery query against an existing model.

A typical query would be to find some element with a specific semantic ID.
In this case the data consumer only knows the external ID whereas the provider may have created a duplicate of the concept definition as ConceptDescription and a model reference could be used

Matching does not mean to define equivalence classes that allow to overwrite constraints as defined in the specification for valid instances of the metamodel.
====

**Exact matching of two references**

* Two References are identical if all attributes values are identical.

[.underline]#Examples for non-matching external referencesfootnote:[The example only contains arbitrary IRDIs and does not represent a real-world example.]:#

[listing]
....
(GlobalReference)0173-1#01-ADS698#010, (GlobalReference)0173-1#01-ADS700#010
....

is not exact match for

[listing]
....
(GlobalReference 0173-1#01-ADS698#010, (FragmentReference)0173-1#01-ADS700#010
....

but a value match.

**Value matching of two references**

* An external reference A matches an external reference B if all values of all keys are identical.

====
Note: it is unlikely that a fragment value is identical to a global reference value; it will reference something different.
====

* A model reference A matches a model reference B if all values of all keys are identical.

====
Note: the key type can be ignored since the fragment keys are always unique (e.g. all idShorts of submodel elements in a submodel or all submodel elements in a submodel element list or collection).
====

* An external reference A matches a model reference B and vice versa if all values of all keys are identical.

* The Reference/type and Reference/referredSemanticId are ignored for matching.

====
Note: since identifiables of the Asset Administration Shell are globally unique, model references are special cases of global references.
The only difference is the handling of key types that are predefined for Asset Administration Shell elements.
Other key types could be predefined, e.g. for IRDI-Paths etc.
However, so far only generic key types are supported.
====

====
Note: If the values for attribute "referredSemanticId" of the two references compared are not identical then there is a mismatch between the two that should be resolved.
However, the two are considered to match in the context of discovery.
====

====
Note: if the key types are not identical although all key values follow the correct order of the key chain, then at least one of the references is buggy and a warning should be issued.
====

The definition of link:https://www.w3.org/TR/xmlschema-2/#terminology[XML Schema] is used for matching

* (Of string or names:) Two strings or names being compared must be identical.

* Characters with multiple possible representations in ISO/IEC 10646 (e.g. characters with both precomposed and base+diacritic forms) match only if they have the same representation in both strings

* No case folding is performed.

* (Of strings and rules in the grammar:) A string matches a grammatical production if it belongs to the language generated by that production.

"

[.underline]#Examples for matching external referencesfootnote:[The example only contains arbitrary IRDIs and does not represent a real-world example.]:#

[listing]
....
(GlobalReference)0173-1#01-ADS698#010, (GlobalReference)0173-1#01-ADS700#010
....

matches

[listing]
....
(GlobalReference 0173-1#01-ADS698#010, (FragmentReference)0173-1#01-ADS700#010
....

[.underline]#Examples for non-matching external references:#

[listing]
....
(GlobalReference)https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, (FragmentReference)Bibliography
....

does not match

[listing]
....
(GlobalReference)https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, (FragmentReference)Bibliographie
....

[.underline]#Examples for matching model references:#

Although these two model references would match according to the matching rules, other rules are violated, i.e. that the ID of the submodel is unique.
If the ID of a submodel is unique, it is not possible that there are two direct submodel element children with the same name (here: Specification).
It is also not possible that two different versions of the same submodel are compared here, because we would then assume that the ID also contains the version information (see Clause xref:spec-metamodel/common.adoc#administrative-information-attributes[Administrative Information Attributes]).
The matching algorithm would still identify these two model references as matching although one of them is buggy.

[listing]
....
(Submodel)https://example.com/aas/1/1/1234859590, (File)Specification
....

matches

[listing]
....
(Submodel)https://example.com/aas/1/1/1234859590, (Blob)Specification
....

[.underline]#Examples for matching model and external references:#

[listing]
....
(Submodel)https://example.com/aas/1/1/1234859590
....

matches

[listing]
....
(GlobalReference)\https://example.com/aas/1/1/1234859590
....

====
Note: this kind of Submodel matching might occur if a SubmodelElement of type ReferenceElement is matched against a query for this element.
It is not allowed to substitute the Submodel references within AssetAdministrationShell/submodels with an external reference!
====

[listing]
....
(Submodel)https://example.com/aas/1/1/1234859590, (File)Specification (FragmentReference)Bibliography
....

matches

[listing]
....
(GlobalReference)https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, (FragmentReference)Bibliography
....

[#submodel-instances-and-templates]
== Submodel Instances and Templates

=== Can New or Proprietary Submodels be Formed?

It is in the interest of Industry 4.0 for as many submodels as possible, including free and proprietary submodels, to be formed (see xref:bibliography.adoc#bib4[[4\]], "Free property sets").
A submodel can be formed at any time for a specific Administration Shell of an asset.
The provider of the Administration Shell can form in-house identifiers for the type and instance of the submodel in line with Clause xref:general.adoc#identification-of-elements[Identification of Elements].
All I4.0 systems are called on to ignore submodels and properties that are not individually known.
Hence, it is always possible to deposit proprietary – e.g. manufacturer-specific or user-specific – information, submodels, or properties in an Administration Shell.

====
Note: it is the intention of the Administration Shell to include proprietary information, e.g. to link to company-wide identification schemes or information required for company-wide data processing.
This way, a single infrastructure can be used to transport standardized and proprietary information at the same time.
New information elements can also be conveyed and introduced (and standardized at a later stage).
====

=== Creating a Submodel Instance Based on an Existing Submodel Template

A public specification of a submodel template (e.g. via publication by Plattform Industrie 4.0) should be available to instantiate an existing submodel template.
In special cases, a submodel can also be instantiated from a non-public submodel template, such as a manufacturer specification.

In November 2020, the first two submodel templates for the Asset Administration Shell were published, one for a nameplate xref:bibliography.adoc#bib40[[40\]] and one for generic technical data xref:bibliography.adoc#bib39[[39\]].
Others followed and will follow.
Please see xref:bibliography.adoc#bib45[[45\]] for an overview of registered submodel templates.

The identifiers of concept definitions to be used as semantic references are already predefined in each submodel template.
An instantiation of such a submodel merely requires the creation of properties with a semantic reference to the property definition and an attached value.
The same applies to other subtypes of submodel elements.

The only thing that cannot be defined in the template itself is the unique ID of the submodel instance itself (it is not identical to the ID of the submodel template), as well as the property values, etc.
Templates also define cardinalities, for example whether an element is optional or not.
Submodel element lists typically contain more than one element: the template contains an exemplary element template; the other elements can be created by copy/paste from this template.

include::./includes/events.adoc[]