////
Copyright (c) 2023 Industrial Digital Twin Association

This work is licensed under a [Creative Commons Attribution 4.0 International License](
https://creativecommons.org/licenses/by/4.0/). 

SPDX-License-Identifier: CC-BY-4.0

Illustrations:
Plattform Industrie 4.0; Anna Salari, Publik. Agentur für Kommunikation GmbH, designed by Publik. Agentur für Kommunikation GmbH
////



:toc: left
:toclevels: 4
:toc-title: Specification of the Asset Administration Shell. Part 1: Metamodel
:sectlinks:
:sectnums:
:imagesdir: ../images/
:nofooter:


include::IDTA-01001_Constraints.adoc[]




== Introduction

This document specifies the metamodel of the Asset Administration Shell.

The general concept and the structure of the Asset Administration Shell is described in IEC 63278-1 (see Figure 1).

.Asset Administration Shell and Related Roles (Source: IEC 63278-1)
image::image2.png[]

These are the main specifics and roles defined for the Asset Administration Shell:

* an Asset Administration Shell has an association to an asset,
* an Asset Administration Shell provides an interface or several interfaces,
* an Asset Administration Shell lists one or several submodels,
* an Asset Administration Shell responsible creates and governs the Asset Administration Shell,
* an Asset Administration Shell user application accesses the information of the Asset Administration Shell via IT interface(s).
* a Submodel template guides the creation of a submodel following the template,
* a Submodel template may reference concept dictionaries and ontologies,
* concept dictionaries and ontologies define the common vocabulary as basis for interoperability,
* submodels may reference the asset services provided by an asset via an asset integration; further services related to the asset can be referenced.

This document specifies a technology-neutral specification of the information metamodel of the Asset Administration Shell in UML. It serves as the basis for deriving several different formats for exchanging Asset Administration Shells, e.g. for XML, JSON, RDF, AutomationML, and OPC UA information models.

Figure 2 shows the different ways of exchanging information Asset Administration Shells. This part of the "Asset Administration Shell in Detail" series is the basis for all of these types of information exchange.

.Types of Information Exchange via Asset Administration Shells
image::image3.jpeg[]

File exchange (1) is described in detail in Part 5 of this document series.

The API (2) based on the information metamodel specified in this document is specified in Part 2 of the document series "Details of the Asset Administration Shell" link:#bib37[[37\]].

The I4.0 language (3) is based on the information metamodel specified in this document link:#bib47[[47\]].

== General

=== Introduction

Before specifying the information metamodel of the Asset Administration Shell, some general topics relevant for the Asset Administration Shell are explained.

Subclause 4.2 describes some general aspects of handling type and instance assets.

Subclause 4.3 explains the very important aspects of identification in the context of the Asset Administration Shell.

Subclause 4.4 provides matching strategies for semantic identifiers and references.

Subclause 4.5 explains the difference between submodel instances and templates.

Subclause 4.6 discusses aspects of event handling.

=== Types and Instances

==== Life Cycle with Type Assets and Instance Assets

Industry 4.0 utilizes an extended understanding of assets, comprising elements such as factories, production systems, equipment, machines, components, produced products and raw materials, business processes and orders, immaterial assets (such as processes, software, documents, plans, intellectual property, standards), services, human personnel, etc..

The RAMI4.0 model link:#bib3[[3\]] defines a generalized life cycle concept derived from IEC 62890. The basic idea is to distinguish between possible types and instances for all assets within Industry 4.0. This makes it possible to apply the type/instance distinction for all elements such as material type/material instance, product type/product instance, machine type/ machine instance, etc. Business-related information is handled on the 'business' layer of the RAMI4.0 model. The business layer also covers order details and workflows, again for both type and instance assets.


====
Note: to distinguish asset 'type' and asset 'instance', the term 'asset kind' is used in this document. The three different relationship classes between assets, especially type assets and instance assets, explained below show why the distinction is so important. The attribute "derivedFrom" in the metamodel is used to explicitly state a relationship between assets that are being derived from one another. Other relationships are not explicitly supported by the metamodel of the Asset Administration Shell, but they can be modelled via the "RelationshipElement" submodel element type.
====


Table 1 gives an overview of the different life cycle phases and the role of type assets and instance assets as well as their relationship in these phases.

This important relationship should be maintained throughout the life of the instance assets. It makes it possible to forward updates from the type assets to the instance assets, either automatically or on demand.



.Life Cycle Phases and Roles of Type and Instance Assets
[cols="20%,22%,58%", options=header]
|===
|*Asset Kind* |*Life Cycle Phase* |*Description*
|Type asset |Development |Valid from the ideation/conceptualization to the first prototypes/test. The 'type' of an asset is defined; distinguishing properties and functionalities are defined and implemented. All (internal) design artefacts associated with the type asset are created, such as CAD data, schematics, embedded software.
| |Usage/ +
Maintenance |Ramping up production capacity. The 'external' information associated to the asset is created, such as technical data sheets, marketing information. The selling process starts.
|Instance asset |Production |Instance assets are created/produced, based on the type asset information. Specific information about production, logistics, qualification, and test are associated with the instance assets.
| |Usage/ +
Maintenance a|
Usage phase by the purchaser of the instance assets. Usage data is associated with the instance asset and might be shared with other value chain partners, such as the manufacturer of the instance asset.

Also included: maintenance, re-design, optimization, and de-commissioning of the instance asset. The full life cycle history is associated with the asset and might be archived/shared for documentation.

|===

The second class of relationships are feedback loops/information within the life cycle of the type asset and instance asset. For product assets, for example, information on usage and maintenance of product instances may be used to improve product manufacturing as well as the design of the (next) product type.

The third class of relationships are feedforward/information exchange with assets of other asset classes. For example, sourcing information from business assets can influence design aspects of products; or the design of the products affects the design of the manufacturing line.


====
Note: the NIST model link:#bib49[[49\]] provides an illustration of the second/third class of relationships.
====


A fourth class of relationships consists between assets of different hierarchy levels. For example, these could be the (dynamic) relationships between manufacturing stations and currently produced products. They could be also the decomposition of production systems in physical, functional, or safety hierarchies. In this class of relationships, automation equipment is seen as a complex, interrelated graph of automation devices and products, performing intelligent production and self-learning/optimization tasks.

Details and examples for composite I4.0 Components can be found in link:#bib12[[12\]]. A composite I4.0 Component is the combination of a complex asset and its Asset Administration Shell. The hierarchy, typically a Bill of Material (BOM) but also any other relationship between different assets, can be represented in one of its submodels.


====
Note: for submodels representing the Bill of Material of a complex asset, the metamodel not only provides the possibility to define relationships (via the submodel element "RelationshipElement", see above), it also explicitly supports the representation of another asset (via the submodel element "Entity"). The term "Entity" is chosen as superordinate concept in this context and refers to either an asset or another item that is not an asset but may be part of a more complex item or asset.
====


====  Asset Administration Shells Representing Type Assets and Instance Assets

An Asset Administration Shell either represents a type asset or an instance asset. Typically, there is a relationship between instance assets and a type asset. However, not every instance asset is required to have a corresponding type asset.

gives an example of how to handle type assets and their derived instance assets. The attribute "assetKind" indicates whether the Asset Administration Shell (denoted by the ": AAS" UML notation for a class instance) represents a type asset or an instance asset. Additionally, attributes are added to show that the attributes of type asset and instance assets typically differ from each other.

.Example: Asset Administration Shells for Type and Instance Assets
image::image4.png[]


====
Note 1: the example is simplified for ease of understanding and only roughly complies with the metamodel as specified in Clause 5. The ID handling is simplified as well: the names of the classes correspond to the unique global identifier of the Asset Administration Shells.
====



====
Note 2: in the context of Plattform Industrie 4.0, types and instances typically refer to "type assets" and "instance assets". When referring to types or instances of an Asset Administration Shell, this is explicitly denoted as "Asset Administration Shell types" and "Asset Administration Shell instances" to not mix them up. Asset Administration Shell types are synonymously used with the term "Asset Administration Shell template".
====



====
Note 3: please refer to 2 for the IEC definition of types and instances. Within the scope of this document, there is no full equivalency between these definitions and the type/instance concepts of object-oriented programming (OO).
====


There shall be a concrete type asset of a temperature sensor and two uniquely identifiable physical temperature sensors of this type. The intention is to provide a separate Asset Administration Shell for the type asset as well as for every single instance asset.

In the example, the first sensor has the unique ID "0215551AAA_T1" and the second sensor has the unique ID "0215551AAA_T2". "0215551AAA_T1" and "0215551AAA_T2" are the global asset IDs of the two assets, i.e. sensors. The Asset Administration Shell for the first sensor has the unique URI "http://T1.com" and the Asset Administration Shell for the second sensor has the unique URI "http://T2.com". The asset kind of both is "Instance". The example shows that the measured temperature at operation time of the two sensors is different: for T1 it is 60 °C, for T2 it is 100 °C. For the time-being we ignore the relationship "derivedFrom" of the two Asset Administration Shells "http://T1.com " and "http://T2.com" with Asset Administration Shell "http://T0215551AA.com".


====
Note 1: even though the HTTP scheme is used for the identifier, please be aware that these identifiers are logical ones. Identifiers do not have to be URLs. At the same time, URLs used as identifiers do not have to refer to accessible content.
====



====
Note 2: the physical unit can be obtained by the semantic reference of the element "measuredTemperature". This is not shown in the example for simplicity reasons.
====


These two instance assets share a lot of information on the type asset (in this example a sensor type), for which an own Asset Administration Shell is created. The unique ID for this Asset Administration Shell is "http://T0215551AA.com", the unique ID of the sensor type is "0215551AA". The asset kind is "Type" and not "Instance". The information shared by all instances of this temperature sensor type is the product class (="Component"), the manufacturer (="ExampleManufacturer"), the English Description (=”precise and fast temperature measurement"), and the value range ("-40 °C / 140 °C").

Now the two Asset Administration Shells of the two instance assets may refer to the Asset Administration Shell of the type asset "0215551AA" using the relationship attribute "derivedFrom".


====
Note 1: in the UML sense, "attribute" refers to the property or characteristic of a class (instance).
====



====
Note 2: if a specific type asset exists, it typically exists in time before the respective instance assets.
====



====
Note 3: the term Asset Administration Shell is used synonymously with the term Asset Administration Shell instance. An Asset Administration Shell may be realized based on an Asset Administration Shell type. Asset Administration Shell types are out of the scope of this document.
====



====
Note 4: in public standardization, the Asset Administration Shell types might be standardized. However, it is much more important to standardize the property types (called property definitions or concept descriptions) or other submodel element types as well as complete submodel types because these can be reused in different Asset Administration Shells.
====



====
Note 5: in the domain of the Internet of Things (IoT), instance assets are typically denoted as "Things" whereas type assets are denoted as "Product".
====


====  Asset Administration Shell Types and Instances

In the previous clause, type assets and instance assets were explained. The obvious question now is how to harmonize Asset Administration Shells and Asset Administration Shell types. The example in shows that the attributes "globalAssetId" and "assetKind" as well as the global Asset Administration Shell identifier (_id_, represented as name of the class) are present for all Asset Administration Shells. However, if there is no standard, the semantics of "id", "globalAssetId" or "kind" are not clear, although they are the same for all Asset Administration Shells. It is also not clear, which of the attributes are mandatory and which are specific for the asset (type or instance), as illustrated in .

This is the purpose of this document: the definition of a metamodel that defines which attributes are mandatory and which are optional for all Asset Administration Shells. The Plattform Industrie 4.0 metamodel for Asset Administration Shells is defined in Clause 5.


====
Note 1: the metamodel of the Asset Administration Shell is suitable for type assets or instance assets. An alternative approach could have been to define two metamodels, one for type assets and one for instance assets. However, the large set of similarities led to the decision of only one metamodel.
====



====
Note 2: the metamodel itself does not require the existence of mandatory submodels. This is another step of standardization similar to the standardization of submodels of the Asset Administration Shell type level.
====



====
Note 3: an Asset Administration Shell type shall be realized based on the metamodel of an Asset Administration Shell as defined in this document. This metamodel is referred to as "Asset Administration Shell Metamodel".
====



====
Note 4: it is not mandatory to define an Asset Administration Shell type before defining an Asset Administration Shell (instance). An Asset Administration Shell instance that does not realize an Asset Administration Shell type shall be realized based on the metamodel of an Asset Administration Shell as defined in this document.
====


.Example: Asset Administration Shell, Asset Administration Shell Types and Instances
image::image5.png[]

=== Identification of Elements

====  Overview

According to link:#bib4[[4\]], identifiers are needed for the unique identification of many different elements within the domain of smart manufacturing. They are a fundamental element of a formal description of the Administration Shell. Identification is especially required for

* Asset Administration Shells,
* assets,
* submodel instances and submodel templates,
* property definitions/concept descriptions in external repositories, such as ECLASS or IEC CDD.

Identification will take place for two purposes

* to uniquely distinguish all elements of an Administration Shell and the asset it is representing, and
* to relate elements to external definitions, such as submodel templates and property definitions, in order to bind semantics to this data and the functional elements of an Administration Shell.

==== Identifiers for Assets and Administration Shells

In the domain of smart manufacturing, the assets need to be uniquely identified worldwide link:#bib4[[4\]] link:#bib20[[20\]] by the means of identifiers (IDs). The Administration Shell also has a unique ID (see Figure 5).

.Unique Identifier for Administration Shell and Asset (Modified Figure from link:#bib4[[4\]])
image::image6.jpeg[]

An Administration Shell represents exactly one asset, with a unique asset ID. In a batch-based production, the batches will become the assets and will be described by a respective Administration Shell. If a set of assets shall be described by an Administration Shell, a unique ID for the composite asset needs to be created link:#bib13[[13\]].

The ID of the asset needs to comply with the restrictions for global identifiers according to link:#bib4[[4\]]link:#bib20[[20\]]. If the asset features further identifications like serial numbers and alike, they are not to be confused with the unique global identifiers of the asset itselffootnote:[Such additional asset identifiers are contained in _AssetInformation/specificAssetIds_.].

====  What Type of Identifiers Exist?

In link:#bib4[[4\]]link:#bib20[[20\]], two standard-conforming global identification types are defined:

* *IRDI* – ISO29002-5, ISO IEC 6523 and ISO IEC 11179-6 link:#bib20[[20\]] as an identifier scheme for properties and classifications. They are created in a process of consortium-wise specification or international standardization. To this end, users come together and feed their ideas into the consortia or standardization bodies. Properties in ISO, IEC help to safeguard key commercial interests. Repositories like ECLASS and others make it possible to standardize a relatively large number of identifiers in an appropriately short time.
* *IRI* – IRI (link:https://tools.ietf.org/html/rfc3987[RFC 3987]) or URI and URL according to link:https://tools.ietf.org/html/rfc3986[RFC 3986] as identification of assets, Administration Shells and other (probably not standardized, but globally unique) properties and classifications.

The following is also permitted:

* *Custom* – internal custom identifiers such as UUIDs/GUIDs (link:https://en.wikipedia.org/wiki/Universally_unique_identifier[universally unique identifiers]/globally unique identifiers), which a manufacturer can use for all sorts of in-house purposes within the Administration Shell.

This means that the IRIs/URIs/URLs and internal custom identifiers can represent and communicate manufacturer-specific information and functions in the Administration Shell and the 4.0 infrastructure just as well as standardized information and functions. One infrastructure can serve both purposes.

CLSID are URIs for GUIDs. They start with a customer specific schema. Hence, Custom should really only be used if the customer-specific identifier is no IRDI nor IRI.

Besides the global identifiers, there are also identifiers that are unique only within a defined namespace, typically its parent element. These identifiers are also called local identifiers. For example, properties within a submodel have local identifiers.

Besides absolute URIs there are also relative URIs.

See also DIN SPEC 91406 link:#bib31[[31\]] for further information on identification.

====  Which Identifiers for Which Elements?

Not every identifier is applicable for every element of the UML model representing the Asset Administration Shell. Table 2 therefore gives an overview on the different constraints and recommendations on the various entities, which implement "Identifiable" or "HasSemantics". Attributes relate to the metamodel in Clause 5.1 and Clause 5.3.

See Annex A for more information on how to create new identifiers and best practices for creating URI identifiers.

.Elements with Allowed Identifying Values
[cols="21%,17%,22%,40%",options="header",]
|===
|*Elements with identifying values* |*Attribute* |*Allowed identifiers (recommended or typical)* |*Remarks*
|xref:AssetAdministrationShell[AssetAdministrationShell] |id |IRI (URL) a|
mandatory

Typically, URLs will be used.

| |idShort |string |optionalfootnote:[Note: in version V1.0 of this specification, idShort was optional for identifiables. This changed in V2.0: idShort was set to mandatory for all referables. With V3.0, idShort was again made optional.]
| |displayName |multi language string |optional
|xref:AssetInformation[AssetInformation] |globalAssetId |IRI a|
recommended

As soon as the Asset Administration Shell is "released" for production or operation, a globalAssetId should be assigned.

An Asset ID may be retrieved e.g., by a QR code on the asset, by an RFID for the asset, from the firmware of the asset, or from an asset database. IEC 61406 (formerly DIN SPEC 91406) defines the format of such Asset IDs.

| |specificAssetId |IRI, Custom a|
recommended

An asset typically may be represented by several different identification properties like for example the serial number, its RFID code etc.

They are used for lookup of Asset Administration Shells in cases the globalAssetId is not available. However, they do not need to be globally unique.

|xref:Submodel[Submodel] with kind = Template |id |IRDI, IRI (URI) a|
mandatory

IRDI, if the defined submodel is standardized and has been assigned an IRDI.

| |idShort |string a|
recommended

Typically used as idShort for the submodel of kind Instance as well

| |displayName |multi language string a|
recommended

Typically used as displayName for the submodel of kind Instance as well

| |semanticId |IRDI, IRI (URI) a|
recommended

The semantic ID might refer to an external semantic model defining the semantics of the submodel.

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:Submodel[Submodel] with kind = Instance |id |IRI (URI), Custom |mandatory
| |idShort |string a|
recommended

Typically, the idShort or English short name of the submodel template that is referenced via semanticId.

| |displayName |multi language string |optional
| |semanticId |IRDI, IRI (URI) a|
recommended

Typically, the semanticId is an external reference to an external standard defining the semantics of the submodel.

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:SubmodelElement[SubmodelElement] |idShort |string a|
mandatory

Typically, the English short name of the concept definition that is referenced via semanticId.

| |displayName |multi language string a|
optional

If no display name is defined in the language requested by the application, the display name may be selected in the following order, if available:

* the preferred name in the requested language of the concept description defining the semantics of the element,
* if there is a default language list defined in the application, the corresponding preferred name in the language is chosen according to this order,
* the English preferred name of the concept description defining the semantics of the element,
* the short name of the concept description,
* the idShort of the element.

| |semanticId |IRDI, IRI (URI), Custom a|
recommended

link to a _ConceptDescription_ or the concept definition in an external repository via a global ID

| |supplementalSemanticId |IRDI, IRI (URI) |optional
|xref:ConceptDescription[ConceptDescription] |id |IRDI, IRI, Custom a|
mandatory

_ConceptDescription_ needs to have a global ID. If the concept description is a copy from an external dictionary like ECLASS or IEC CDD, it may use the same global ID as it is used in the external dictionary.

| |idShort |string a|
recommended

e.g. same as English short name

| |displayName |multi language string |optional
| |isCaseOf |IRDI, IRI (URI) a|
optional

links to the concept definition in an external repository, which the concept description is a copy from, or that it corresponds to

|xref:Qualifier[Qualifier] |semanticId |IRDI, IRI (URI), Custom a|
recommended

Links to the qualifier type definition in an external repository

IRDI, if the defined qualifier type is standardized and has been assigned an IRDI.

|===

==== Usage of Short ID for Identifiable Elements

The Administration Shell fosters the use of worldwide unique identifiers to a large degree. However, in some cases, this may lead to inefficiencies. Example: a property, which is part of a submodel, which in turn is part of an Administration Shell, each of which is identified by global identifiers link:#bib4[[4\]].

In an application featuring a resource-oriented architecture (ROA), a worldwide unique resource locator (URL) might be composed of a series of segments, which do not need to be globally unique, see Figure 6.

.Motivation of Exemplary Identifiers and idShort
image::image7.jpeg[]

To allow such efficient addressing by the chaining of elements by an API of an Administration Shell, _idShort_ is provided for a set of classes of the metamodel. It inherits from the abstract class _Referable_, in order to refer to such dependent elements (see 5.1).

Before accessing concrete data provided via a submodel, an application typically checks if the submodel provides the required data, i.e. the semantics of the submodel is checked for suitability. A so-called _semanticId_ should be defined for this submodel as well as the submodel element. This semantic ID helps to easily find the semantic definition of the submodel (see Clause 5.3.2).

=== Matching Strategies

==== Matching Strategies for Semantic Identifiers

When comparing two elements, different use cases should be considered in order to define how these two elements are semantically related. This clause gives first hints on the aspects to consider when dealing with matching semantic identifiers. For example, semantic references including context information as represented in IRDI-Path in ECLASS are not yet considered. Sometimes a concept description is derived from another concept description or is identical to or at least compatible with another concept description. The metamodel foresees an attribute "isCaseOf" for such semantic IDs. However, these are not considered in the matching strategies described in this clause.

*Exact Matching (identical semanticIds) – DEFAULT*

* With exact matching, two semantic IDs need to be string-identical.
** Example: Property with idShort "ManufacturerName" + semanticId 0173-1#02-AAO677#002 and Property with idShort "Herstellername" + semanticId 0173-1#02-AAO677#002 have exactly equal semantics.

*Intelligent Matching (compatible semanticIds)*

* Ignore Versioning
** With intelligent matching, different versions of a concept definition may be matched. For example, if semantic versioning is used to version the concept description, then upward or backward compatible versions can be matched.
** Example: property with idShort "ManufacturerName" + semanticId 0173-1#02-AAO677#002 and Property with idShort "Herstellername" + semanticId 0173-1#02-AAO677#003 have equal semantics.

====
Note: to compare two semantic IDs, knowledge about versioning needs to be available. In the example above, two IRDIs from ECLASS are compared. ECLASS rules ensure that the semantics is always backward compatible for new versions; a new IRDI would be created for breaking changes.
====

* Consider Semantic Mappings
** Existing semantic mapping information can be considered for intelligent matching. Semantic mappings may exist within one and the same dictionary, but also between different dictionaries and ontologies.
** Example: 0112/2///61360_4#AAE530 for nominal capacity of a battery in dictionary IEC CDD and 0173-1#02-AAI048#004 in ECLASS have equal semanticsfootnote:[Semantic mapping files are also used in ECLASS between ECLASS Classic and ECLASS Advanced: https://eclass.eu/support/technical-specification/data-model/basic-advanced-mapping] footnote:[This is the format used for semantic mapping in ECLASS: https://eclass.eu/fileadmin/Redaktion/pdf-Dateien/Wiki/ECLASSXML_3.0/ECLASS_XML/mapping.xsd].
====
Note: this example does not represent an existing semantic mapping; it is only a candidate.
====

====
Note: this example does not represent an existing semantic mapping; it is only a candidate.
====

* Consider Domain Knowledge
** With intelligent matching, domain knowledge available in machine-readable form may be taken into account, such as an "is-a"-relationship between two concept definitions.
** Example: a Hammer drill (0173-1#01-ADS698#010) and a percussion drill (0173-1#01-ADS700#010) are drills for mineral material (0173-1#01-ADN177#005) and are compatible with a request or constraints asking for drills for mineral material.

==== Matching Algorithm for References

Clause 4.4.1 has discussed matching strategies for semantic identifiers. This clause explains matching strategies based on the reference concept (see Clause 5.3.10) in more detail and covers other kinds of identifying elements.

For example, the string serialization of references as defined in Clause 7.2.3 is used for easier understanding.

Exact matching of two references

* An external reference A matches an external reference B if all values of all keys are identical.


====
Note: it is unlikely that a fragment value is identical to a global reference value; it will reference something different.
====


A model reference A matches a model reference B if all values of all keys are identical. +

====
Note: the key type can be ignored since the fragment keys are always unique (e.g. all idShorts of submodel elements in a submodel or all submodel elements in a submodel element list or collection).
====


* An external reference A matches a model reference B and vice versa if all values of all keys are identical.


====
Note: since identifiables of the Asset Administration Shell are globally unique, model references are special cases of global references. The only difference is the handling of key types that are predefined for Asset Administration Shell elements. Other key types could be predefined, e.g. for IRDI paths etc. However, so far only generic key types are supported.
====



====
Note: if the key types are not identical although all key values follow the correct order of the key chain, then at least one of the references is buggy and a warning should be issued.
====


The definition of link:https://www.w3.org/TR/xmlschema-2/#terminology[XML Schema] is used for matching

* "(Of string or names:) Two strings or names being compared must be identical.
* Characters with multiple possible representations in ISO/IEC 10646 (e.g. characters with both precomposed and base+diacritic forms) match only if they have the same representation in both strings.
* No case folding is performed.
* (Of strings and rules in the grammar:) A string matches a grammatical production if it belongs to the language generated by that production."

[.underline]#Examples for matching external referencesfootnote:[The example only contains arbitrary IRDIs and does not represent a real-world example.]:#

*(GlobalReference)0173-1#01-ADS698#010, (GlobalReference)0173-1#01-ADS700#010*

matches

*(GlobalReference 0173-1#01-ADS698#010, (FragmentReference)0173-1#01-ADS700#010*

[.underline]#Examples for non-matching external references:#

*(GlobalReference)\https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, +
(FragmentReference)Bibliography*

does not match

*(GlobalReference)\https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, +
(FragmentReference)Bibliographie*

[.underline]#Examples for matching model references:#

Although these two model references would match according to the matching rules, other rules are violated, i.e. that the ID of the submodel is unique. If the ID of a submodel is unique, it is not possible that there are two direct submodel element children with the same name (here: Specification). It is also not possible two different versions of the same submodel are compared here, because we would then assume that the ID also contains the version information (see Clause 5.3.2.2). The matching algorithm would still identify these two model references as matching although one of them is buggy.

*(Submodel)\https://example.com/aas/1/1/1234859590, (File)Specification*

*(Submodel)\https://example.com/aas/1/1/1234859590, (Blob)Specification*

[.underline]#Examples for matching model and external references:#

*(Submodel)\https://example.com/aas/1/1/1234859590*

is identical to

*(GlobalReference)\https://example.com/aas/1/1/1234859590*

*(Submodel)\https://example.com/aas/1/1/1234859590, (File)Specification (FragmentReference)Bibliography*

is identical to

*(GlobalReference)\https://example.com/aas/1/1/1234859590, (FragmentReference)Specification, +
(FragmentReference)Bibliography*

=== Submodel Instances and Templates

==== Can New or Proprietary Submodels be Formed?

It is in the interest of Industry 4.0 for as many submodels as possible, including free and proprietary submodels, to be formed (see link:#bib4[[4\]], "Free property sets"). A submodel can be formed at any time for a specific Administration Shell of an asset. The provider of the Administration Shell can form in-house identifiers for the type and instance of the submodel in line with Clause 4.3. All I4.0 systems are called on to ignore submodels and properties that are not individually known. Hence, it is always possible to deposit proprietary – e.g. manufacturer-specific or user-specific – information, submodels, or properties in an Administration Shell.


====
Note: it is the intention of the Administration Shell to include proprietary information, e.g. to link to company-wide identification schemes or information required for company-wide data processing. This way, a single infrastructure can be used to transport standardized and proprietary information at the same time. New information elements can also be conveyed and introduced (and standardized at a later stage).
====


==== Creating a Submodel Instance Based on an Existing Submodel Template

A public specification of a submodel template (e.g. via publication by Plattform Industrie 4.0) should be available to instantiate an existing submodel template. In special cases, a submodel can also be instantiated from a non-public submodel template, such as a manufacturer specification.

In November 2020, the first two submodel templates for the Asset Administration Shell were published, one for a nameplate link:#bib40[[40\]] and one for generic technical data link:#bib39[[39\]]. Others followed and will follow. Please see link:#bib45[[45\]] for an overview of registered submodel templates.

The identifiers of concept definitions to be used as semantic references are already predefined in each submodel template. An instantiation of such a submodel merely requires the creation of properties with a semantic reference to the property definition and an attached value. The same applies to other subtypes of submodel elements.

The only thing that cannot be defined in the template itself is the unique ID of the submodel instance itself (it is not identical to the ID of the submodel template), as well as the property values, etc. Templates also define cardinalities, for example whether an element is optional or not. Submodel element lists typically contain more than one element: the template contains an exemplary element template; the other elements can be created by copy/paste from this template.

=== Events

====  Overview

Events are a very versatile mechanism of the Asset Administration Shell. The following subclauses describe some use cases for events. They summarize different types of events to depict requirements, introduce a _SubmodelElement_ “_Event_" to enable declaration of events of an Asset Administration Shell. Further, the general format of event messages is specified.


====
Note: the concept of event is still in the experimental phase. Please be aware that backward compatibility cannot be ensured for future versions of the metamodel.
====


====  Brief Use Cases for Events Used in Asset Administration Shells

* Event use cases are briefly outlined in the following (see also ):

image::image8.jpeg[]

* An integrator has purchased a device. Later in time, the supplier of the device provides a new firmware. The integrator wants to detect the offer of a new firmware and wants to update the firmware after evaluating its suitability ("forward events"). A dependent Asset Administration Shell ("D4") detects events from a parent or type Asset Administration Shell ("D1"), which is described by the _derivedFrom_ relation. An illustration of the use case is given in Figure 7.
* An integrator/operator operates a motor purchased from a supplier. During operation, condition monitoring incidents occur. Both parties agree on a business model providing availability. The supplier wants to monitor device statuses which are located further in the value chain ("reverse events"). An illustration of the use case is given in Figure 7.

.Forward and Reverse Events
image::image8.jpeg[]

* An operator is operating a certain I4.0 component over time. Changes that occasionally occur to these I4.0 components from different systems shall be tracked for documentation and auditing purposes. This can be achieved by recording events over time. An illustration of the use case is given in Figure 8.

.Tracking of Changes via Events
image::image9.jpeg[]

* An operator is operating different I4.0 components, which are deployed to manufacturer clouds. The operator wants to integrate data from these components, according to DIN SPEC 92222. For this purpose, information needs to be forwarded to the operator cloud ("value push"). An illustration of the use case is given in Figure 9.

.Value Push Events Across Clouds
image::image10.jpeg[]

====  Input and Output Directions of Events

We can distinguish between incoming and outgoing events. See Table 3 for more information on the event directions.

.Directions of Events
[cols="32%,68%",options="header",]
|===
|*Direction* |*Description*
|Out |The event is monitoring the _Referable_ it is attached to. An outer message infrastructure, e.g. by OPC UA, MQTT or AMQP, will transport these events to other Asset Administration Shells, further outer systems and users.
|In |The software entity, which implements the respective _Referable_, can handle incoming events. These incoming events will be delivered by an outer message infrastructure, e.g. OPC UA, MQTT or AMQP, to the software entity of the _Referable_.
|===

==== Types of Events

The uses cases described in Clause 4.6.2 need different types of events. Each event type is identified by a _semanticId_ and features a specialized payload.

Table 4 gives an overview of types of events. The possible directions of an event are described in Clause 4.6.3.

.Types of Events
[cols="26%,12%,62%",options="header",]
|===
|*Group* |*Direction* |*Motivation / Conditions*
|Structural changes of the Asset Administration Shell |Out a|
* CRUDfootnote:[Create, Retrieve, Update, Delete] of Submodels, Assets, SubmodelElements, etc.

| |In a|
* Detect updates on parent/type/_derivedFrom_ Asset Administration Shell

|Updates of properties and dependent attribute |Out a|
* update of values of SubmodelElements
* time-stamped updates and time series updates
* explicit triggering of an update event

|Operation element of Asset Administration Shell |Out a|
* monitoring of (long-lasting) execution of _OperationElement_ and updating events during execution

|Monitoring, conditional, calculated events |Out a|
* e.g. when voiding some limits (e.g. stated by Qualifiers with expression semantics)

|Infrastructure events |Out a|
* Booting, shutdown, out of memory, etc. of software entity of respective Referable (Asset Administration Shell, Submodel)

|Repository events |In/ Out a|
* Change of semantics of IRDIs (associated concept definition)

|Security events |Out a|
* logging events
* access violations, unfitting roles and rights, denial of service, etc.

|Alarms and events |Out a|
* alarms and events management analog to distributed control systems (DCS)

|===

*Custom Event Types*

Custom event types can be defined by using a proprietary, but worldwide unique, semanticId for this event type. Such customized events can be sent or received by the software entity of the respective referable, based on arbitrary conditions, triggers, or behavior. While the general format of the event messages needs to comply with this specification, the payload might be completely customized.

*Event Scopes*

Events can be stated with an _observableReference_ to the _Referables_ of Asset Administration Shell, __Submodel__s, and _SubmodelElements._ These _Referables_ define the scope of the events, which are to be received or sent. +
Table 5 describes the different scopes of an event.

.Event Scopes
[cols="32%,68%",options="header",]
|===
|*Event attached to ...* |*Scope*
|xref:AssetAdministrationShell[AssetAdministrationShell] |This event monitors/represents all logical elements of an Administration Shell, such as _AssetAdministrationShell, AssetInformation, Submodels_.
|xref:Submodel[Submodel] |This event monitors/represents all logical elements of the respective _Submodel_ and all logical dependents.
|xref:SubmodelElementList[SubmodelElementList] and xref:SubmodelElementCollection[SubmodelElementCollection] and xref:Entity[Entity] |This event monitors/represents all logical elements of the respective _SubmodelElementCollection, SubmodelElementList or Entity_ and all logical dependents (value or statement resp.).
|xref:SubmodelElement[SubmodelElement] (others) |This event monitors/represents a single atomic _SubmodelElement_, e.g. a data element which might include the contents of a _Blob_ or _File_.
|===

== The Information Metamodel of the Asset Administration Shell (normative)

=== Introduction

This clause specifies the information metamodel of the Asset Administration Shell.

An overview of the metamodel of the Asset Administration Shell is given in Subclause 5.1; Subclause 5.3 describes the classes and all their attributes in detail.

The legend of the UML diagrams and the table specification of the classes is explained in Annex D and Annex E. Readers familiar with UML may skip the first clause in Annex E. It is however recommended to have a look at the specifics used in this modelling, especially those on dealing with model references.


====
Note: an xmi representation of the UML model can be found in the repository "aas-specs" in the github project admin-shell-io *link:#bib51[[51\]]*: https://github.com/admin-shell-io/aas-specs/tree/master/schemas/xmi
====


=== Overview Metamodel of the Asset Administration Shell

This clause gives an overview of the main classes of the Asset Administration Shell (AAS) metamodel.

Figure 10 shows the main classes to describe a single Asset Administration Shell.

An Asset Administration Shell represents exactly one asset (_AssetAdministrationShell/assetInformation_). Type assets and instance assets are distinguished by the attribute "_AssetInformation/assetKind_". See Clause 5.3.4 for details.


====
Note: the UML modelling uses so-called abstract classes for denoting reused concepts like "HasSemantics", "Qualifiable" etc.
====


In case of an Asset Administration Shell of an instance asset, a reference to the Asset Administration Shell representing the corresponding type asset or another instance asset it was derived from may be added (_AssetAdministrationShell/derivedFrom_). The same holds true for the Asset Administration Shell of an type asset. Types can also be derived from other types.

.Overview Metamodel of the Asset Administration Shell
image::image11.png[]

An asset may typically be represented by several different identification properties like the serial number, the manufacturer part ID or the different customer part IDs, its RFID code, etc. Such external identifiers are defined as specific asset IDs, each characterized by a user-defined name, a value, and the user domain (tenant, subject in Attribute Based Access Control; _AssetInformation/specificAssetId_). See Clause 5.3.4 for details. Additionally, a global asset identifier should be assigned to the asset (_AssetInformation/globalAssetId_) in the production and operation phase.

Asset Administration Shells, submodels and concept descriptions need to be globally uniquely identifiable (_Identifiable_). Other elements like properties only need to be referable within the model and thus only require a local identifier (_idShort_ from _Referable_). For details on identification, see Clause 4.3; details on _Identifiable_ and _Referable_ are provided in Clause 5.3.2.7 and Clause 5.3.2.10.

__Submodel__s consist of a set of submodel elements. Submodel elements may be qualified by a so-called _Qualifier_. There might be more than one qualifier per _Qualifiable_. See Clause 5.3.2.8 and Clause 5.3.2.9 for details.

There are different subtypes of submodel elements like properties, operations, lists, etc. See Clause 5.3.7 for details. A typical submodel element is shown in the overview figure: a property is a data element that has a value of simple type like string, date, etc. Every data element is a submodel element (not visible in the figure but implicitly the case, since _DataElement_ is inheriting from _SubmodelElement_). For details on properties, see Clause 5.3.7.12.

Every submodel element needs a semantic definition _(semanticId_ in _HasSemantics_) to have a well-defined meaning. The submodel element might either refer directly to a corresponding semantic definition provided by an external reference (e.g. to an ECLASS or IEC CDD property definition) or it may indirectly reference a concept description (_ConceptDescription_). See Clause 4.4.1 for matching strategies, and Clause 5.3.2.6 for details.

A concept description may be derived from another property definition of an external standard or another concept description (_ConceptDescription/isCaseOf_). _isCaseOf_ is a more formal definition of _sourceOfDefinition_, which is just text.


====
Note: in this case, most of the attributes are redundant because they are defined in the external standard. Attributes for information like _preferredName_, _unit_ etc. are added to increase usability. Consistency w.r.t. the referenced submodel element definitions should be ensured by corresponding tooling.
====


If a concept description is not just a copy or refinement of an external standard, the provider of the Asset Administration Shell using this concept description shall be aware that an interoperability with other Asset Administration Shells cannot be ensured.

Data specification templates (_DataSpecification_) can be used to define a named set of additional attributes (besides those predefined by the metamodel) for an element. The data specification template following IEC 61360 is typically used for the concept description of properties, providing e.g. an attribute "preferredName". The _\<<template>>_ dependency is used to denote recommended data specification templates. See Clause 5.3.2.2 for details.

Data specification templates like the template for IEC 61360 property definitions (Part 3a) are explicitly predefined and recommended to be used by Plattform Industrie 4.0. See Clause 6 for details. If proprietary templates are used, interoperability with other Asset Administration Shells cannot be ensured.

Besides submodel elements including properties and concept descriptions, other identifiable elements may also use additional templates (_HasDataSpecification_). Data specification templates are selected at design time. Further details are provided in Clause 6.

Figure 12 gives a complete overview of all elements defined in the metamodel and specified in Clause 5.3. The UML packages reflect the structure of Clause 5.3. The elements of package "Core" are specified as first class citizens in Clause 5.3, except for their imported packages: the elements of package "SubmodelElements" are specified in Clause 5.3.6. Elements of package "Common" are specified in Clause 5.3.2. The elements of package "Reference" are specified in Clause 5.3.10. Elements from package "Types" are specified in Clause 5.3.11. The only package that is not listed is "Data Specifications (Templates)" because data specifications are handled differently. Data specification templates are explained in Clause 6.


====
Note: the abstract classes are numbered h0_, h1_, etc. (e.g. h1_Referable); their aliases however are defined without this prefix. The reason for this naming is that no order for inherited classes can be defined in the tooling used for UML modelling (Enterprise Architect), since they are ordered alphabetically. The order is important for some serializations (e.g. for XML).
====


Figure 11 shows the so-called environment. The environment’s purpose is to list all Asset Administration Shells, all submodels, and all concept descriptions – in other word, all identifiables within an ecosystem.

.Metamodel of Environment
image::image12.png[]

.Metamodel Package Overview
image::image13.png[]

=== Metamodel Specification Details: Designators

==== General

This clause specifies the classes of the metamodel in detail. An overview is provided in Clause 5.2. Annex E explains UML modelling together with the specifics used in this specification. Annex D depicts the templates used to describe the classes and relationships. Annex G shows some of the diagrams together with all their inherited attributes to give a complete overview.

To understand the specifications, it is crucial to understand the common attributes first (Clause 5.3.2). They are reused throughout the specifications of the other classes ("inherits from") and define important concepts like identifiable, qualifiable, etc. They are abstract, i.e. there is no object instance of such classes.

The concept of referencing and how a reference is represented in the UML diagrams and the tables is explained in Clause 5.3.9 and Annex E.

Constraints that are no invariants of classes are specified in Clause 5.3.11.3.

==== Common Attributes

===== General

This clause specifies the abstract classes that represent commonly used attributes and terminology, together with the classes and data types exclusively used in these classes. They are represented in alphabetical order.

===== Administrative Information Attributes

.Metamodel of Administrative Information
image::image14.png[]

Every identifiable may contain administrative information. Administrative information includes, for example,

* information about the version of the element,
* information about who created or who made the last change to the element,
* information about the languages available in case the element contains text; the master or default language may also be defined for translating purposes,
* information about the submodel template that guides the creation of the submodel

In principle, the version corresponds to the _version_identifier_ according to IEC 62832. However, it is not used for concept identifiers only (IEC TS 62832-1), but for all identifiable elements. Together, version and revision correspond to the version number according to IEC 62832.

Other attributes of the administrative information like creator refer to ISO 15836-1:2017, the Dublin Core metadata element set.

For more information on the concept of subject, see Attribute Based Access Control (ABAC) link:#bib49[[49\]]. The assumption is that every subject has a unique identifier.

_AdministrativeInformation_ allows the usage of templates (_HasDataSpecification_). Data specifications are defined in separate documents.


====
Note 1: two submodels with the same semanticId but different administrative information shall have different IDs (_Submodel/id_), since they denote that the submodel is not backward compatible or has some other major administrative changes. The _idShort_ typically does not change. The same applies to other identifiables (_Identifiable/id_). Otherwise, the ID of a submodel would not be sufficient to identify the data or service provided by the submodel.
====



====
Note 2: since submodels with different versions shall have different identifiers, it is possible that an Asset Administration Shell has two submodels with the same _semanticId_ but different versions, i.e. different administrative metainformation.
====



====
Note 3: some of the administrative information like the version number might need to be part of the identification. This is similar to the handling of identifiers for concept descriptions using IRDIs. In ECLASS, the IRDI 0173-1#02-AO677#002 contains the version information #002.
====



====
Note 4: the process of versioning or adding other administrative information to elements is done by external version or configuration management software and not by the Asset Administration Shell itself.
====

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[AdministrativeInformation]]AdministrativeInformation
|Explanation: a|
Administrative metainformation for an element like version information

{aasd005}

|Inherits from: |xref:HasDataSpecification[HasDataSpecification]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|version |Version of the element |xref:VersionType[VersionType] |0..1
|revision |Revision of the element |xref:RevisionType[RevisionType] |0..1
|creator |The subject ID of the subject responsible for making the element |xref:Reference[Reference] |0..1
|templateId a|
Identifier of the template that guided the creation of the element


====
Note 1: in case of a submodel, the template ID is the identifier of the submodel template that guided the creation of the submodel.
====



====
Note 2: the submodel template ID is not relevant for validation. Here, the _Submodel/semanticId_ shall be used.
====



====
Note 3: usage of the template ID is not restricted to submodel instances. The creation of submodel templates can also be guided by another submodel template.
====


|xref:Identifier[Identifier] |0..1
|===

===== Has Data Specification Attributes

.Metamodel of HasDataSpecification
image::image15.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[HasDataSpecification]]HasDataSpecification \<<abstract>>
|Explanation: |Element that can be extended by using data specification templates. A data specification template defines a named set of additional attributes an element may or shall have. The data specifications used are explicitly specified with their global ID.
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|dataSpecification a|
External reference to the data specification template used by the element


====
Note: this is an external reference.
====


|xref:Reference[Reference] |0..* |
|===

For more details on data specifications, please see Clause 6.

===== Extensions Attributes

.Metamodel of Has Extensions
image::image16.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[HasExtensions]]HasExtensions \<<abstract>>
|Explanation: a|
Element that can be extended by proprietary extensions


====
Note 1: see Clause 5.3.12.4 for constraints related to extensions.
====



====
Note 2: extensions are proprietary, i.e. they do not support global interoperability.
====



|Inherits from: |-
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|extension |An extension of the element. |xref:Extension[Extension] |0..*
|===

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Extension]]Extension
|Explanation: |Single extension of an element
|Inherits from: |xref:HasSemantics[HasSemantics]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|name |Name of the extension |xref:NameType[NameType] |1
|valueType a|
Data type of the value attribute of the extension

Default: xs:string

|xref:DataTypeDefXsd[DataTypeDefXsd]|0..1
|value |Value of the extension |xref:ValueDataType[ValueDataType] |0..1
|refersTo |Reference to an element the extension refers to |ModelReference<xref:Referable[Referable]> |0..*
|===



===== Has Kind Attributes

.Metamodel of HasKind
image::image17.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[HasKind]]HasKind
|Explanation: a|
An element with a kind is an element that can either represent a template or an instance.

Default for an element is that it is representing an instance.


|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|kind a|
Kind of the element: either template or instance

Default Value = _Instance_

|xref:ModellingKind[ModellingKind]|0..1
|===

The kind enumeration is used to denote whether an element is of kind _Template_ or _Instance_. It is used to distinguish between submodels and submodel templates.

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[ModellingKind]]ModellingKind
|Explanation: |Enumeration for denoting whether an element is a template or an instance
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|Template |specification of the common features of a structured element in sufficient detail that such a instance can be instantiated using it
|Instance |concrete, clearly identifiable element instance. Its creation and validation may be guided by a corresponding element template
|===

===== Has Semantics Attributes

.Metamodel of Semantic References (HasSemantics)
image::image18.png[]

For matching algorithm, see Clause 4.4.1.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[HasSemantics]]HasSemantics \<<abstract>>
|Explanation: a|
Element that can have a semantic definition plus some supplemental semantic definitions

{aasd118}


|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|semanticId a|
Identifier of the semantic definition of the element called semantic ID or also main semantic ID of the element


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|supplementalSemanticId a|
Identifier of a supplemental semantic definition of the element called supplemental semantic ID of the element


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..*
|===

===== Identifiable Attributes

.Metamodel of Identifiables
image::image19.png[]

An identifiable element is a referable with a globally unique identifier (_Identifier_). Only the global ID (_Identifiable/id_) shall be used to reference an identifiable, because the _idShort_ is not unique for an identifiable. Identifiables may have administrative information like version, etc.

Non-identifiable referable elements can be referenced. However, this requires the context of the element. A referable that is not identifiable and not child within a SubmodelElementList has a short identifier (_idShort_) that is unique just in its context, its name space.

Information about identification can be found in Clause 4.3. See Clause 4.3.4 for constraints and recommendations on when to use which type of identifier.

See Clause 4.3.4 for information about which identifier types are supported.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Identifiable]]Identifiable \<<abstract>>
|Explanation: a|
An element that has a globally unique identifier


====
Note: see Clause 5.3.12.2 for constraints related to identifiables.
====



|Inherits from: |xref:Referable[Referable]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|administration a|
Administrative information of an identifiable element


====
Note: some of the administrative information like the version number might need to be part of the identification.
====


|xref:AdministrativeInformation[AdministrativeInformation] |0..1
|id |The globally unique identification of the element |xref:Identifier[Identifier] |1
|===

===== Qualifiable Attributes

.Metamodel of Qualifiables
image::image20.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Qualifiable]]Qualifiable \<<abstract>>
|Explanation: a|
A qualifiable element may be further qualified by one or more qualifiers.


====
Note: see Clause 5.3.12.3 for constraints related to qualifiables.
====



|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|qualifier |Additional qualification of a qualifiable element |xref:Qualifier[Qualifier] |0..*
|===

===== Qualifier Attributes

.Metamodel of Qualifiers
image::image21.png[]

Qualifiers may be defined for qualifiable elements.

There are standardized qualifiers defined in IEC CDD, IEC61360-4 – IEC/SC 3D. A level qualifier defining the level type minimal, maximal, typical, and nominal value is specified in IEC 62569-1. In DIN SPEC 92000, qualifier types like e.g. expression semantics and expression logic are defined.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Qualifier]]Qualifier
|Explanation: a|
A qualifier is essentially a type-value-pair. Depending on the kind of qualifier, it makes additional statements

* w.r.t. the value of the qualified element,
* w.r.t the concept, i.e. semantic definition of the qualified element,
* w.r.t. existence and other meta information of the qualified element type.

{aasd006}

{aasd020}


|Inherits from: |xref:HasSemantics[HasSemantics]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|Kind \<<Experimental>> a|
The qualifier kind describes the kind of qualifier that is applied to the element.

Default: ConceptQualifier

|xref:QualifierKind[QualifierKind] |0..1
|type |The qualifier type describes the type of qualifier that is applied to the element. |xref:QualifierType[QualifierType] |1
|valueType |Data type of the qualifier _value_ |xref:DataTypeDefXsd[DataTypeDefXsd] |1
|value |The qualifier value is the value of the qualifier. |xref:ValueDataType[ValueDataType] |0..1
|valueId a|
Reference to the global unique ID of a coded value


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|===

It is recommended to add a _semanticId_ for the concept of the _Qualifier_. _Qualifier/type_ is the preferred name of the concept of the qualifier or its short name.

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[QualifierKind]]QualifierKind
|Explanation: |Enumeration for kinds of qualifiers
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|ValueQualifier a|
Qualifies the value of the element; the corresponding qualifier value can change over time.

Value qualifiers are only applicable to elements with __kind__="_Instance"._

|ConceptQualifier |Qualifies the semantic definition (_HasSemantics/semanticId_) the element is referring to; the corresponding qualifier value is static.
|TemplateQualifier a|
Qualifies the elements within a specific submodel on concept level; the corresponding qualifier value is static.


====
Note: template qualifiers are only applicable to elements with kind="Template". See constraint AASd-129.
====


|===

Example of a _ValueQualifier_: property "temperature" and qualifier "value quality" with different qualifier values like "measured", "substitute value".

Example of a _ConceptQualifier:_ an Asset Administration Shell with two submodels with different IDs but the same semanticId = "Bill of Material". The qualifier could denote the life cycle with qualifier values like "as planned", "as maintained" etc. (see +
Figure 21).

Example of a _TemplateQualifier:_ a submodel element with qualifier value "mandatory" or "optional". This qualification is needed to build a correct submodel instance. For more information see link:#bib48[[48\]].

.Example: Qualifier from IEC CDD
image::image22.png[Ein Bild, das Text enthält. Automatisch generierte Beschreibung]

===== Referable Attributes

.Metamodel of Referables
image::image23.png[]

The metamodel differentiates between elements that are identifiable, referable, or none of both. The latter means they are neither inheriting from _Referable_ nor from _Identifiable_, which applies e.g. to __Qualifier__s.

Referable elements can be referenced via the _idShort_ (with exception of elements within a SubmodelElementList). For details on referencing, see Clause 5.3.9.

Not every element of the metamodel is referable. There are elements that are just attributes of a referable.

The __idShort__ shall be unique in its name space for non-identifiable referables (exception: referables within a SubmodelElementList) (see Constraint AASd-022). A name space is defined as follows in this context: the parent element(s), which an element is part of and that is either referable or identifiable, is the name space of the element. Examples: a submodel is the name space for the properties directly contained in it; the name space of a submodel element contained in a submodel element collection is the submodel element collection.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Referable]]Referable \<<abstract>>
|Explanation: a|
Note1 : an element that is referable by its idShort. This ID is not globally unique. This ID is unique within the name space of the element.


====
Note 2: see Clause 5.3.12.2 for constraints related to referables.
====


{aasd002}


|Inherits from: |xref:HasExtensions[HasExtensions]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|category \<<Deprecated>> a|
The category is a value that gives further meta information w.r.t. the class of the element. It affects the expected existence of attributes and the applicability of constraints.


====
Note: The category is not identical to the semantic definition (_HasSemantics_) of an element. The category could e.g. denote that the element is a measurement value, whereas the semantic definition of the element would denote that it is the measured temperature.
====


|xref:NameType[NameType] |0..1
|idShort a|
In case of identifiables, this attribute is a short name of the element. In case of a referable, this ID is an identifying string of the element within its name space.


====
Note: if the element is a property and the property has a semantic definition (_HasSemantics/semanticId_) conformant to IEC61360, the _idShort_ is typically identical to the short name in English, if available.
====


|xref:NameType[NameType] |0..1
|displayName |Display name; can be provided in several languages |xref:MultiLanguageNameType[MultiLanguageNameType] |0..1
|description a|
Description or comments on the element

The description can be provided in several languages.

If no description is defined, the definition of the concept description that defines the semantics of the element is used.

Additional information can be provided, e.g. if the element is qualified and which qualifier types can be expected in which context or which additional data specification templates.

|xref:MultiLanguageTextType[MultiLanguageTextType] |0..1
|===

Predefined categories are described in Table 6.


====
Note: categories are deprecated and should no longer be used.
====


.Categoriesfootnote:[Note: categories of referables are deprecated.] for Elements with Value
[cols="18%,28%,54%",options="header",]
|===
|Category: |Applicable to, Examples: |Explanation:
|CONSTANT a|
Property

ReferenceElement

a|
An element with the category CONSTANT is an element with a value that does not change over time.

In ECLASS, this kind of category has the category "Coded Value".

|PARAMETER a|
Property

MultiLanguageProperty

Range

SubmodelElementCollection

a|
An element with the category PARAMETER is an element that is once set and then typically does not change over time.

This applies e.g. to configuration parameters.

|VARIABLE a|
Property

SubmodelElementList

|An element with the category VARIABLE is an element that is calculated during runtime, i.e. its value is a runtime value.
|===

==== Asset Administration Shell Attributes

.Metamodel of an AssetAdministrationShell
image::image24.png[]

An Administration Shell is uniquely identifiable since it inherits from _Identifiable_.

The _derivedFrom_ attribute is used to establish a relationship between two Asset Administration Shells that are derived from each other. For more detailed information on the _derivedFrom_ concept, see Clause 4.2.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[AssetAdministrationShell]]AssetAdministrationShell
|Explanation: |An Asset Administration Shell
|Inherits from: |xref:Identifiable[Identifiable]; xref:HasDataSpecification[HasDataSpecification]]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|derivedFrom |The reference to the Asset Administration Shell, which the Asset Administration Shell was derived from |ModelReference<xref:AssetAdministrationShell[AssetAdministrationShell]> |0..1
|assetInformation |Meta information about the asset the Asset Administration Shell is representing |xref:AssetInformation[AssetInformation] |1
|submodel a|
Reference to a submodel of the Asset Administration Shell

A submodel is a description of an aspect of the asset the Asset Administration Shell is representing.

The asset of an Asset Administration Shell is typically described by one or more submodels.

Temporarily, no submodel might be assigned to the Asset Administration Shell.

|ModelReference<xref:Submodel[Submodel]> |0..*
|===

==== Asset Information Attributes

.Metamodel of Asset Information
image::image25.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[AssetInformation]]AssetInformation
|Explanation: a|
In _AssetInformation,_ identifying meta data of the asset that is represented by an Asset Administration Shell is defined.

The asset may either represent a type asset or an instance asset.

The asset has a globally unique identifier, plus – if needed – additional domain-specific (proprietary) identifiers. However, to support the corner case of very first phase of life cycle where a stabilized/constant global asset identifier does not already exist, the corresponding attribute "globalAssetId" is optional.

{aasd131}


====
Note: see Clause 5.3.12.5 for constraints related to asset information.
====



|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|assetKind |Denotes whether the _Asset_ is of kind "Type" or "Instance" |xref:AssetKind[AssetKind]|1
|globalAssetId a|
Identifier of the asset the Asset Administration Shell is representing

This attribute is required as soon as the Asset Administration Shell is exchanged via partners in the life cycle of the asset. In a first phase of the life cycle, the asset might not yet have a global asset ID but already an internal identifier. The internal identifier would be modelled via "specificAssetId".

|xref:Identifier[Identifier] |0..1
|specificAssetId |Additional domain-specific, typically proprietary identifier for the asset like serial number, manufacturer part ID, customer part IDs, etc |xref:SpecificAssetId[SpecificAssetId] |0..*
|assetType a|
In case _AssetInformation/assetKind_ is applicable the _AssetInformation/assetType_ is the asset ID of the type asset of the asset under consideration as identified by _AssetInformation/globalAssetId_.


====
Note: in case _AssetInformation/assetKind_ is "Instance" then the AssetInformation/assetType denotes which "Type" the asset is of. But it is also possible to have an _AssetInformation/assetType_ of an asset of kind "Type".
====


|xref:Identifier[Identifier] |0..1
|defaultThumbnail |Thumbnail of the asset represented by the Asset Administration Shell; used as default. |xref:Resource[Resource] |0..1
|===


====
Note: besides this asset information, there still might be an identification submodel with further information. Specific asset IDs mainly serve the purpose of supporting discovery of Asset Administration Shells for an asset.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Resource]]Resource
|Explanation: |Resource represents an address to a file (a locator). The value is a URI that can represent an absolute or relative path.
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|path a|
Path and name of the resource (with file extension)

The path can be absolute or relative.

|xref:PathType[PathType] |1
|contentType a|
Content type of the content of the file

The content type states which file extensions the file can have.

|xref:ContentType[ContentType] |0..1
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[AssetKind]]AssetKind
|Explanation: |Enumeration for denoting whether an asset is a type asset or 
an instance asset or is a role or whether this kind of classification is not applicable
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|Type |Type asset
|Instance |Instance asset
|Role | Role asset
|NotApplicable |Neither a type asset nor an instance asset nor a role asset
|===

For more information on types and instances, see Clause 4.2.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[SpecificAssetId]]SpecificAssetId
|Explanation: a|
A specific asset ID describes a generic supplementary identifying attribute of the asset. The specific asset ID is not necessarily globally unique.

{aasd133}


|Inherits from: |xref:HasSemantics[HasSemantics]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|name |Name of the asset identifier |xref:LabelType[LabelType] |1
|value |The value of the specific asset identifier with the corresponding name |xref:Identifier[Identifier] |1
|externalSubjectId a|
The unique ID of the (external) subject the specific asset ID _value_ belongs to or has meaning to


====
Note: this is an external reference.
====


|xref:Reference[Reference] |0..1
|===


====
Note 1: names for specificAssetIds do not need to be unique.
====



====
Note 2: semanticIds for the single specificAssetIds do not need to be unique.
====


For more information on the concept of subject, see Attribute Based Access Control (ABAC) link:#bib49[[49\]]. The assumption is that every subject has a unique identifier.

==== Submodel Attributes

.Metamodel of Submodel
image::image26.png[]

Adding a _semanticId_ for a submodel is recommended (see Table 2).

If the submodel is of _kind=Template_ (modelling kind as inherited by _HasKind_), the submodel elements within the submodel are presenting submodel element templates. If the submodel is of _kind=Instance_, its submodel elements represent submodel element instances.


====
Note: validators shall handle a submodel like _SubmodelElementCollection/submodelElements_ and not like a _SubmodelElementList/value_. The difference is that a submodel is identifiable and a predefined unit of information within the Asset Administration Shell.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Submodel]]Submodel
|Explanation: a|
A submodel defines a specific aspect of the asset represented by the Asset Administration Shell.

A submodel is used to structure the digital representation and technical functionality of an Administration Shell into distinguishable parts. Each submodel refers to a well-defined domain or subject matter. Submodels can become standardized and, in turn, submodel templates.


|Inherits from: |xref:Identifiable[Identifiable]; xref:HasKind[HasKind]; xref:HasSemantics[HasSemantics]; xref:Qualifiable[Qualifiable]; xref:HasDataSpecification[HasDataSpecification]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|submodelElement |A submodel consists of zero or more submodel elements. |xref:SubmodelElement[SubmodelElement] |0..*
|===

==== Submodel Element Attributes

.Metamodel of Submodel Element
image::image27.png[]

Submodel elements are qualifiable elements, i.e. one or more qualifiers may be defined for each of them.

It is recommended to add a _semanticId_ to a _SubmodelElement._

Submodel elements may also have defined data specification templates. A template might be defined to mirror some of the attributes like _preferredName_ and _unit_ of a property concept definition if there is no corresponding concept description available. Otherwise, there is only the property definition referenced by _semanticId_ available for the property; the attributes must be looked up online in a different way and are not available offline.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[SubmodelElement]]SubmodelElement \<<abstract>>
|Explanation: |A submodel element is an element suitable for the description and differentiation of assets.
|Inherits from: |xref:Referable[Referable]; xref:HasSemantics[HasSemantics]; xref:Qualifiable[Qualifiable]; xref:HasDataSpecification[HasDataSpecification]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|===

==== Overview of Submodel Element Types

.Metamodel Overview for Submodel Element Subtypes
image::image28.png[]

Submodel elements include data properties as well as operations, events and other elements needed to describe a model for an asset (see Figure 27).

===== General

All submodel elements including abstract classes like data elements are specified in alphabetical order.

===== Annotated Relationship Element Attributes

.Metamodel of Annotated Relationship Elements
image::image29.png[]

An annotated relationship is a relationship similar to a ternary association in UML. The semantics of the relationship is defined via the _semanticId_ of the _RelationshipElement_. If this semantic definition requires additional information not contained in the _first_ or _second_ object referenced via the relationship, this information needs to be stored as annotation.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[AnnotatedRelationshipElement]]AnnotatedRelationshipElement
|Explanation: |An annotated relationship element is a relationship element that can be annotated with additional data elements.
|Inherits from: |xref:RelationshipElement[RelationshipElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|annotation |A data element that represents an annotation that holds for the relationship between the two elements |xref:DataElement[DataElement] |0..*
|===

===== Basic Event Element Attributes

.Metamodel of Basic Event Element
image::image30.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[BasicEventElement]]BasicEventElement \<<Experimental>>
|Explanation: |A basic event element
|Inherits from: |xref:EventElement[EventElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|observed |Reference to a referable, e.g. a data element or a submodel that is being observed |ModelReference<xref:Referable[Referable]> |1
|Direction a|
Direction of event

Can be \{ input, output }

|xref:Direction[Direction]|1
|State a|
State of event

Can be \{ on, off }

|xref:StateOfEvent[StateOfEvent]|1
|messageTopic |Information for the outer message infrastructure to schedule the event for the respective communication channel. |xref:MessageTopicType[MessageTopicType] |0..1
|messageBroker a|
Information about which outer message infrastructure shall handle messages for the _EventElement_; refers to a _Submodel,_ _SubmodelElementList_, _SubmodelElementCollection_ or _Entity_, which contains __DataElement__s describing the proprietary specification for the message broker


====
Note: this proprietary specification could be standardized by using respective submodels for different message infrastructure, e.g. OPC UA, MQTT or AMQP.
====


|ModelReference<xref:Referable[Referable]> |0..1
|lastUpdate |Timestamp in UTC, when the last event was received (input direction) or sent (output direction) |dateTime |0..1
|minInterval a|
For input direction reports on the maximum frequency, the software entity behind the respective referable can handle input events.

For output events, the maximum frequency of outputting this event to an outer infrastructure is specified.

Might be not specified, i.e. if there is no minimum interval.

|duration |0..1
|maxInterval a|
Not applicable for input direction

For output direction: maximum interval in time, the respective referable shall send an update of the status of the event, even if no other trigger condition for the event was not met.

Might not be specified, i.e. if there is no maximum interval.

|duration |0..1
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[Direction]]Direction \<<Experimental>>
|Explanation: |Direction
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|input |Input direction
|output |Output direction
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[StateOfEvent]]StateOfEvent \<<Experimental>>
|Explanation: |State of an event
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|on |Event is on
|off |Event is off
|===

Events sent or received by an Asset Administration Shell always comply with a general format. Exception: events exchanged in the course of an Industry 4.0 interaction pattern.

The payload of such an event is specified below.

====
Note: the payload is not part of the information model as exchanged via the AASX package format but used in re-active Asset Administration Shells.
====

.Metamodel of Event Payload
image::image31.png[]


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[EventPayload]]EventPayload \<<Experimental>>
|Explanation: |Defines the necessary information of an event instance sent out or received
|Inherits from: |-
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|source |Reference to the source event element |ModelReference<xref:EventElement[EventElement]> |1
|sourceSemanticId a|
semanticId of the source event element, if available


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|observableReference |Reference to the referable, which defines the scope of the event. |ModelReference<xref:Referable[Referable]> |1
|observableSemanticId a|
semanticId of the referable, which defines the scope of the event, if available.


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|topic |Information for the outer message infrastructure to schedule the event for the respective communication channel |xref:MessageTopicType[MessageTopicType] |0..1
|subjectId a|
Subject, who/which initiated the creation


====
Note: this is an external reference.
====


|xref:Reference[Reference] |0..1
|timestamp |Timestamp in UTC, when this event was triggered |dateTime |1
|payload |Event-specific payload |xref:BlobType[BlobType] |0..1
|===

For more information on the concept of subject, see Attribute Based Access Control (ABAC) link:#bib49[[49\]]. The assumption is that every subject has a unique identifier.

===== Blob Attributes

.Metamodel of Blobs
image::image32.png[]

For information on content type, see Clause 5.3.7.9 on submodel element "File".

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Blob]]Blob
|Explanation: |A Blob is a data element representing a file that is contained in the value attribute with its source code.
|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value a|
The value of the blob instance of a blob data element


====
Note: in contrast to the file property, the file content is stored directly as value in the Blob data element.
====


|xref:BlobType[BlobType] |0..1
|contentType a|
Content type of the content of the blob.

The content type (MIME type) states which file extensions the file can have.

Valid values are content types like "application/json", "application/xls", "image/jpg".

The allowed values are defined as in RFC2046.

|xref:ContentType[ContentType] |1
|===

===== Capability Attributes

.Metamodel of Capabilities
image::image33.png[]


====
Note: the _semanticId_ of a capability is typically an ontology, which enables reasoning on capabilities. For information and examples on how to apply the concept of capability and how to map it to one or more skills implementing the capability, please refer to link:#bib27[[27\]]. The mapping is done via a relationship element with the corresponding semantics. A skill is typically a property or an operation. In more complex cases, the mapping can also be a collection or a complete submodel.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Capability]]Capability
|Explanation: |A capability is the implementation-independent description of the potential of an asset to achieve a certain effect in the physical or virtual world.
|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|===

===== Data Element and Overview of Data Element Types

.Metamodel of Data Elements
image::image34.png[]

A data element is a submodel element that is not further composed of other submodel elements.

A data element is a submodel element that has a value or a predefined number of values like range data elements.

The type of value differs for different subtypes of data elements. Data elements include properties, file handling, and reference elements, see Figure 33.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[DataElement]]DataElement \<<abstract>>
|Explanation: a|
A data element is a submodel element that is not further composed of other submodel elements.

A data element is a submodel element that has a value. The type of value differs for different subtypes of data elements.

{aasd090}


====
Note: categories are deprecated and should no longer be used.
====



|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|===

===== Entity Attributes

.Metamodel of Entities
image::image35.png[]

The entity submodel element is designed to be used in submodels defining the relationship between the parts of the composite asset it is composed of (e.g. bill of material). These parts are called entities. Not all entities have a global asset ID.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Entity]]Entity
|Explanation: a|
An entity is a submodel element that is used to model entities.

{aasd014}


|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|statement |Describes statements applicable to the entity by a set of submodel elements, typically with a qualified value |xref:SubmodelElement[SubmodelElement] |0..*
|entityType |Describes whether the entity is a co-managed entity or a self-managed entity |xref:EntityType[EntityType]|0..1
|globalAssetId |Global identifier of the asset the entity is representing |xref:Identifier[Identifier] |0..1
|specificAssetId |Reference to a specific asset ID representing a supplementary identifier of the asset represented by the Asset Administration Shell |xref:SpecificAssetId[SpecificAssetId] |0..*
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[EntityType]]EntityType
|Explanation: |Enumeration for denoting whether an entity is a self-managed entity or a co-managed entity
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|CoManagedEntity |There is no separate Asset Administration Shell for co-managed entities. Co-managed entities need to be part of a self-managed entity.
|SelfManagedEntity a|
Self-managed entities have their own Asset Administration Shell but can be part of another composite self-managed entity.

The asset of an I4.0 Component is a self-managed entity per definition.

|===

===== Event Attributes

.Metamodel of Events
image::image36.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[EventElement]]EventElement \<<abstract>> \<<Experimental>>
|Explanation: |An event element
|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|===

===== File Attributes

.Metamodel of File Submodel Element
image::image37.png[]

A media type (also MIME type and content type) is a two-part identifier for file formats and format contents transmitted via the Internet. 
The Internet Assigned Numbers Authority (IANA) is the official authority for the standardization and publication of these classifications.


====
Note: for information on handling supplementary external files in exchanging Asset Administration Shells in AASX package format see also 
[Part 5 of the series "Specification of the Asset Administration Shell"](https://industrialdigitaltwin.org/en/content-hub/aasspecifications). 
An absolute path is used in case the file exists independently of the Asset Administration Shell.
A relative path, relative to the package root, should be used if the file is part of a serialized package of the Asset Administration Shell.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[File]]File
|Explanation: |A file is a data element that represents an address to a file (a locator). The value is a URI that can represent an absolute or relative path.
|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value a|
Path and name of the file (with file extension)

The path can be absolute or relative.

|xref:PathType[PathType] |0..1
|contentType |Content type of the content of the file |xref:ContentType[ContentType] |1
|===

===== Multi Language Property Attributes



.Metamodel of Multi Language Properties
image::image38.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[MultiLanguageProperty]]MultiLanguageProperty
|Explanation: a|
A property is a data element that has a multi-language value.

{aasd012}


|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value |The value of the property instance |xref:MultiLanguageTextType[MultiLanguageTextType] |0..1
|valueId a|
Reference to the global unique ID of a coded value.


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|===

===== Operation Attributes

.Metamodel of Operations
image::image39.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Operation]]Operation
|Explanation: a|
An operation is a submodel element with input and output variables.

{aasd134}


|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|inputVariable |Input parameter of the operation |xref:OperationVariable[OperationVariable] |0..*
|outputVariable |Output parameter of the operation |xref:OperationVariable[OperationVariable] |0..*
|inoutputVariable |Parameter that is input and output of the operation |xref:OperationVariable[OperationVariable] |0..*
|===

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[OperationVariable]]OperationVariable
|Explanation: |The value of an operation variable is a submodel element that is used as input and/or output variable of an operation.
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value |Describes an argument or result of an operation via a submodel element |xref:SubmodelElement[SubmodelElement] |1
|===


====
Note 1: operations typically specify the behavior of a component in terms of procedures. Hence, operations enable the specification of services with procedure-based interactions link:#bib23[[23\]].
====



====
Note 2: OperationVariable is introduced as separate class to enable future extensions, e.g. for adding a default value or cardinality (option/mandatory).
====



====
Note 3: even if the submodel element as the value of an input and an output variable have the same idShort, this does not mean that they are identical or mapped to the same variable since OperationVariables are no referables. The same applies to two input variables or an input variable and an inoutputVariable a.s.o.
====


===== Property Attributes

.Metamodel of Properties
image::image40.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Property]]Property
|Explanation: a|
A property is a data element that has a single value.

{aasd007}


|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|valueType |Data type of the value attribute |xref:DataTypeDefXsd[DataTypeDefXsd] |1
|value |The value of the property instance |xref:ValueDataType[ValueDataType] |0..1
|valueId a|
Reference to the global unique ID of a coded value


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|===

===== Range Attributes

.Metamodel of Ranges
image::image41.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Range]]Range \<<Experimental>>
|Explanation: |A range data element is a data element that defines a range with min and max.
|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|valueType |Data type of the min und max attributes |xref:DataTypeDefXsd[DataTypeDefXsd] |1
|min a|
The minimum value of the range

If the min value is missing, the value is assumed to be negative infinite.

|xref:ValueDataType[ValueDataType] |0..1
|max a|
The maximum value of the range

If the max value is missing, the value is assumed to be positive infinite.

|xref:ValueDataType[ValueDataType] |0..1
|===

===== Reference Element Attributes

.Metamodel of Reference Elements
image::image42.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[ReferenceElement]]ReferenceElement
|Explanation: |A reference element is a data element that defines a logical reference to another element within the same or another Asset Administration Shell or a reference to an external object or entity.
|Inherits from: |xref:DataElement[DataElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value |External reference to an external object or entity or a logical reference to another element within the same or another Asset Administration Shell (i.e. a model reference to a _Referable_) |xref:Reference[Reference] |0..1
|===

For more information on references, see Clause 5.3.9.

===== Relationship Element Attributes

.Metamodel of Relationship Elements
image::image43.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[RelationshipElement]]RelationshipElement
|Explanation: |A relationship element is used to define a relationship between two elements being either referable (model reference) or external (external reference).
|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|first |Reference to the first element in the relationship taking the role of the subject |xref:Reference[Reference] |1
|second |Reference to the second element in the relationship taking the role of the object |xref:Reference[Reference] |1
|===

===== Submodel Element Collection Attributes

.Metamodel of Submodel Element Collections
image::image44.png[]

Submodel Element Collections are used for complex elements with a typically fixed set of properties with unique names. This set of properties is typically predefined by the semantic definition (referenced via _semanticId_) of the submodel element collection. Each property within the collection itself should have clearly defined semantics.


====
Note: the different elements of a submodel element collection do not have to have different __semanticId__s. However, in these cases the usage of a _SubmodelElementList_ should be considered.
====


Example: a single document has a predefined set of properties like title, version, author, etc. They logically belong to a document. So a single document is represented by a _SubmodelElementCollection_. An asset usually has many different documents available like operating instructions, safety instructions, etc. The set of all documents is represented by a _SubmodelElementList_ (see Clause _5.3.7.17)_. In this case, we have a _SubmodelElementList_ of __SubmodelElementCollection__s.


====
Note: the elements within a submodel element collection are not ordered. Every element has a unique ID (its "idShort"). However, it is recommended to adhere to the order defined in the submodel template.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[SubmodelElementCollection]]SubmodelElementCollection
|Explanation: |A submodel element collection is a kind of struct, i.e. a logical encapsulation of multiple named values.
|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|value |Submodel element contained in the collection |xref:SubmodelElement[SubmodelElement] |0..*
|===

===== Submodel Element List Attributes

.Metamodel of Submodel Element Lists
image::image45.png[]

Submodel element lists are used for sets (i.e. unordered collections without duplicates), ordered lists (i.e. ordered collections that may contain duplicates), bags (i.e. unordered collections that may contain duplicates), and ordered sets (i.e. ordered collections without duplicates).


====
Note: there is no _idShort_ for submodel elements in lists (see Constraint AASd-120).
====


Submodel element lists are also used to create multi-dimensional arrays. A two-dimensional array listlink:#bib3[[3\]]link:#bib5[[5\]] with _Property_ values would be realized like follows: the first submodel element list would contain three _SubmodelElementList_ elements. Each of these three _SubmodelElementLists_ would contain 5 single _Property_ elements. The _semanticId_ of the contained properties would be the same for all lists in the first list, i.e. _semanticIdListElement_ would be identical for all three lists contained in the first list. The _semanticId_ of the three contained lists would differ depending on the dimension it represents. In case of complex values in the array, a _SubmodelElementCollection_ would be used as values in the leaf lists.

Similarly, a table with three columns can be represented. In this case a _SubmodelElementCollection_ with three _SubmodelElementLists_ would be contained and the _semanticId_ as well as the _semanticIdListElement_ for the three columns would differ.

Matching strategies for semantic IDs are explained in Clause 4.4.1.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[SubmodelElementList]]SubmodelElementList
|Explanation: a|
A submodel element list is an ordered list of submodel elements.


====
Note: the list is ordered although the ordering might not be relevant (see attribute "orderRelevant".)
====


The numbering starts with Zero (0).

{aasd107}

{aasd114}

{aasd115}

{aasd108}

{aasd109}


|Inherits from: |xref:SubmodelElement[SubmodelElement]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|orderRelevant a|
Defines whether order in list is relevant. If _orderRelevant_ = false, the list represents a set or a bag.

Default: True

|boolean |0..1
|value |Submodel element contained in the list |xref:SubmodelElement[SubmodelElement] |0..*
|semanticIdListElement a|
Semantic ID which the submodel elements contained in the list match


====
Note: it is recommended to use an external reference.
====


|xref:Reference[Reference] |0..1
|typeValueListElement |The submodel element type of the submodel elements contained in the list |xref:AasSubmodelElements[AasSubmodelElements]|1
|valueTypeListElement |The value type of the submodel element contained in the list |xref:DataTypeDefXsd[DataTypeDefXsd]|0..1
|===

==== Concept Description Attributes

.Metamodel of Concept Descriptions
image::image46.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[ConceptDescription]]ConceptDescription
|Explanation: a|
The semantics of a property or other elements that may have a semantic description is defined by a concept description.

The description of the concept should follow a standardized schema (realized as data specification template).


|Inherits from: |xref:Identifiable[Identifiable]; xref:HasDataSpecification[HasDataSpecification]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|isCaseOf a|
Reference to an external definition the concept is compatible to or was derived from


====
Note: it is recommended to use an external reference, i.e. _Reference/type = ExternalReference_.
====



====
Note: compare with is-case-of relationship in ISO 13584-32 & IEC EN 61360
====


|xref:Reference[Reference] |0..*
|===

Different types of submodel elements require different attributes to describe their semantics. This is why a concept description has at least one data specification template associated with it. This template defines the attributes needed to describe the semantics.

See Clause 5.3.11.3 for predefined data specification templates.

==== Environment Attributes

.Metamodel for Environment
image::image47.png[]


====
Note: _Environment_ is not an identifiable or referable element. It is introduced to enable file transfer as well as serialization.
====


[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Environment]]Environment
|Explanation: |Container for the sets of different identifiables
|Inherits from: |xref:Reference[Reference]
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|assetAdministrationShell |Asset Administration Shell |xref:AssetAdministrationShell[AssetAdministrationShell] |0..*
|submodel |Submodel |xref:Submodel[Submodel] |0..*
|conceptDescription |Concept description |xref:ConceptDescription[ConceptDescription] |0..*
|===

==== Referencing in Asset Administration Shells

===== Overview

To date, two kinds of references are distinguished: references to external objects or entities (external reference) and references to model elements of the same or another Asset Administration Shell (model reference). Model references are also used for metamodel inherent relationships like submodels of an Asset Administration Shell (notation see Annex A).

An external reference is a unique identifier. The identifier can be a concatenation of different identifiers, representing e.g. an IRDI path.


====
Note: references should not be mixed up with locators. Even URLs can be used as identifiers and do not necessarily describe a resource that can be accessed.
====


=====  Reference Attributes

.Metamodel of Reference
image::image48.png[]

See Clause 4.4.2 for reference matching.

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Reference]]Reference
|Explanation: a|
Reference to either a model element of the same or another Asset Administration Shell or to an external entity

A model reference is an ordered list of keys, each key referencing an element. The complete list of keys may, for example, be concatenated to a path that gives unique access to an element.

An external reference is a reference to an external entity.


|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|type a|
Type of the reference

Denotes whether reference is an external reference or a model reference

|xref:ReferenceTypes[ReferenceTypes]|1
|referredSemanticId a|
Expected semantic ID of the referenced model element (_Reference/type=ModelReference_); there typically is no semantic ID for for the referenced object of external references _(Reference/type=ExternalReference)_.


====
Note 1: if Reference/referredSemanticId is defined, the semanticId of the model element referenced should have a matching semantic ID. If this is not the case, a validator should raise a warning.
====



====
Note 2: it is recommended to use an external reference for the semantic ID expected from the referenced model element.
====


|xref:Reference[Reference] |0..1
|key \<<ordered>> |Unique reference in its name space |xref:Key[Key] |1..*
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[ReferenceTypes]]ReferenceTypes
|Explanation: |Enumeration for denoting whether an element is an external or model reference
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|ExternalReference |External reference
|ModelReference |Model reference
|===

===== Key Attributes

.Metamodel of Keys
image::image49.png[]

Keys are used to define references (_Reference_).

Figure 49 presents a logical model of key types. These logical enumerations are used to formulate constraints.

.Logical Model for Keys of References (non-normative)
image::image50.png[]

.Metamodel of KeyTypes Enumeration
image::image51.png[]

[.table-with-appendix-table]
[cols="25%h,75%"]
|===
|Class: |[[Key]]Key
|Explanation: |A key is a reference to an element by its ID
|Inherits from: |--
|===
[cols="25%,40%,25%,10%",options="header"]
|===
|Attribute |Explanation |Type |Card.
|type a|
Denotes which kind of entity is referenced

If _Key/type = GlobalReference,_ the key represents a reference to a source that can be globally identified.

If _Key/type = FragmentReference,_ the key represents a bookmark or a similar local identifier within its parent element as specified by the key that precedes this key.

In all other cases, the key references a model element of the same or another Asset Administration Shell. The name of the model element is explicitly listed.

|xref:KeyTypes[KeyTypes]|1
|value |The key value, for example an IRDI or an URI |xref:Identifier[Identifier] |1
|===

An example for using a _FragmentId_ as type of a key is a reference to an element within a file that is part of an Asset Administration Shell aasx package.

.Metamodel of AasSubmodelElements Enumeration
image::image52.png[]

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[KeyTypes]]KeyTypes
|Explanation: |Enumeration of different key value types within a key
|Set of: |FragementKeys; xref:AasReferables[AasReferables], xref:GloballyIdentifiables[GloballyIdentifiables]
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AnnotatedRelationshipElement[AnnotatedRelationshipElement] |Annotated relationship element
|xref:AssetAdministrationShell[AssetAdministrationShell] |Asset Administration Shell
|xref:BasicEventElement[BasicEventElement] |Basic event element
|xref:Blob[Blob] |Blob
|xref:Capability[Capability] |Capability
|xref:ConceptDescription[ConceptDescription] |Concept Description
|xref:DataElement[DataElement] a|
Data Element


====
Note: data elements are abstract, i.e. if a key uses "DataElement", the reference may be a property, file, etc.
====


|xref:Entity[Entity] |Entity
|xref:EventElement[EventElement] a|
Event


====
Note: event element is abstract.
====


|xref:File[File] |File
|FragmentReference |Bookmark or a similar local identifier of a subordinate part of a primary resource
|GlobalReference |Global reference
|xref:Identifiable[Identifiable] a|
Identifiable


====
Note: identifiable is abstract, i.e. if a key uses "Identifiable" the reference may be an Asset Administration Shell, a submodel or a concept description.
====


|xref:MultiLanguageProperty[MultiLanguageProperty] |Property with a value that can be provided in multiple languages
|xref:Operation[Operation] |Operation
|xref:Property[Property] |Property
|xref:Range[Range] |Range with min and max
|xref:Referable[Referable] |
====
Note: referables are abstract, i.e. if a key uses "Referable", the reference may be an Asset Administration Shell, a property, etc.
====

|xref:ReferenceElement[ReferenceElement] |Reference
|xref:RelationshipElement[RelationshipElement] |Relationship
|xref:Submodel[Submodel] |Submodel
|xref:SubmodelElement[SubmodelElement] a|
Submodel element


====
Note: submodel elements are abstract, i.e. if a key uses "SubmodelElement", the reference may be a property, a submodel element list, an operation, etc.
====


|xref:SubmodelElementCollection[SubmodelElementCollection] |Struct of submodel elements
|xref:SubmodelElementList[SubmodelElementList] |List of submodel elements
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[FragmentKeys]]FragmentKeys
|Explanation: a|
Enumeration of different fragment key value types within a key


====
Note: not used as type but in constraints.
====


|Set of: |xref:AasReferableNonIdentifiables[AASReferableNonIdentifiables], xref:GenericFragmentKeys[GenericFragmentKeys]
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AnnotatedRelationshipElement[AnnotatedRelationshipElement] |Annotated relationship element
|xref:BasicEventElement[BasicEventElement] |Basic event element
|xref:Blob[Blob] |Blob
|xref:Capability[Capability] |Capability
|xref:DataElement[DataElement] a|
Data element


====
Note: data elements are abstract, i.e. if a key uses "DataElement", the reference may be a property, a file, etc.
====


|xref:Entity[Entity] |Entity
|xref:EventElement[EventElement] a|
Event


====
Note: event elements are abstract.
====


|xref:File[File] |File
|FragmentReference |Bookmark or a similar local identifier of a subordinate part of a primary resource
|xref:MultiLanguageProperty[MultiLanguageProperty] |Property with a value that can be provided in multiple languages
|xref:Operation[Operation] |Operation
|xref:Property[Property] |Property
|xref:Range[Range] |Range with min and max
|xref:ReferenceElement[ReferenceElement] |Reference
|xref:RelationshipElement[RelationshipElement] |Relationship
|xref:SubmodelElement[SubmodelElement] a|
Submodel element


====
Note: submodel elements are abstract, i.e. if a key uses "SubmodelElement", the reference may be a property, a submodel element list, an operation, etc.
====


|xref:SubmodelElementCollection[SubmodelElementCollection] |Struct of submodel elements
|xref:SubmodelElementList[SubmodelElementList] |List of submodel elements
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[GloballyIdentifiables]]GloballyIdentifiables
|Explanation: a|
Enumeration of different key value types within a key


====
Note: not used as type but in constraints.
====


|Set of: |xref:AasIdentifiables[AasIdentifiables], xref:GenericGloballyIdentifiables[GenericGloballyIdentifiables]
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AssetAdministrationShell[AssetAdministrationShell] |Asset Administration Shell
|xref:ConceptDescription[ConceptDescription] |Concept description
|GlobalReference |Global reference
|xref:Identifiable[Identifiable] a|
Identifiable


====
Note: identifiables are abstract, i.e. if a key uses "Identifiable", the reference may be an Asset Administration Shell, a submodel, or a concept description.
====


|xref:Submodel[Submodel] |Submodel
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[AasReferableNonIdentifiables]]AasReferableNonIdentifiables
|Explanation: a|
Enumeration of different fragment key value types within a key


====
Note: not used as type but in constraints.
====


|Set of: |xref:AasSubmodelElements[AasSubmodelElements]
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AnnotatedRelationshipElement[AnnotatedRelationshipElement] |Annotated relationship element
|xref:BasicEventElement[BasicEventElement] |Basic event element
|xref:Blob[Blob] |Blob
|xref:Capability[Capability] |Capability
|xref:DataElement[DataElement] a|
Data element


====
Note: data elements are abstract, i.e. if a key uses "DataElement", the reference may be a property, a file, etc.
====


|xref:Entity[Entity] |Entity
|xref:EventElement[EventElement] a|
Event


====
Note: event elements are abstract.
====


|xref:File[File] |File
|xref:MultiLanguageProperty[MultiLanguageProperty] |Property with a value that can be provided in multiple languages
|xref:Operation[Operation] |Operation
|xref:Property[Property] |Property
|xref:Range[Range] |Range with min and max
|xref:ReferenceElement[ReferenceElement] |Reference
|xref:RelationshipElement[RelationshipElement] |Relationship
|xref:SubmodelElement[SubmodelElement] a|
Submodel element


====
Note: submodel elements are abstract, i.e. if a key uses "SubmodelElement", the reference may be a property, a SubmodelElementList, an operation, etc.
====


|xref:SubmodelElementCollection[SubmodelElementCollection] |Struct of submodel elements
|xref:SubmodelElementList[SubmodelElementList] |List of submodel elements
|===

[.table-with-appendix-table]
[cols="30%h,70%,1%"]
|===
|Enumeration: |[[AasSubmodelElements]]AasSubmodelElements |
|Explanation: |Enumeration of different fragment key value types within a key |
|Set of: |-- |
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AnnotatedRelationshipElement[AnnotatedRelationshipElement] |Annotated relationship element
|xref:BasicEventElement[BasicEventElement] |Basic event element
|xref:Blob[Blob] |Blob
|xref:Capability[Capability] |Capability
|xref:DataElement[DataElement] a|
Data element


====
Note: data elements are abstract, i.e. if a key uses "DataElement", the reference may be a property, a file, etc.
====


|xref:Entity[Entity] |Entity
|xref:EventElement[EventElement] a|
Event


====
Note: event elements are abstract.
====


|xref:File[File] |File
|xref:MultiLanguageProperty[MultiLanguageProperty] |Property with a value that can be provided in multiple languages
|xref:Operation[Operation] |Operation
|xref:Property[Property] |Property
|xref:Range[Range] |Range with min and max
|xref:ReferenceElement[ReferenceElement] |Reference
|xref:RelationshipElement[RelationshipElement] |Relationship
|xref:SubmodelElement[SubmodelElement] a|
Submodel element


====
Note: Submodel elements are abstract, i.e. if a key uses "SubmodelElement", the reference may be a property, a SubmodelElementList, an operation, etc.
====


|xref:SubmodelElementCollection[SubmodelElementCollection] |Struct of submodel elements
|xref:SubmodelElementList[SubmodelElementList] |List of submodel elements
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[AasReferables]]AasReferables
|Explanation: a|
Enumeration of referables


====
Note: not used as type but in constraints.
====


|Set of: |xref:AasReferableNonIdentifiables[AASReferableNonIdentifiables], xref:AasIdentifiables[AasIdentifiables]
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AssetAdministrationShell[AssetAdministrationShell] |Asset Administration Shell
|xref:ConceptDescription[ConceptDescription] |Concept description
|xref:Identifiable[Identifiable] a|
Identifiable


====
Note: Identifiables are abstract, i.e. if a key uses "Identifiable", the reference may be an Asset Administration Shell, a submodel, or a concept description.
====


|xref:Submodel[Submodel] |Submodel
|xref:AnnotatedRelationshipElement[AnnotatedRelationshipElement] |Annotated relationship element
|xref:BasicEventElement[BasicEventElement] |Basic event element
|xref:Blob[Blob] |Blob
|xref:Capability[Capability] |Capability
|xref:DataElement[DataElement] a|
Data element


====
Note: data elements are abstract, i.e. if a key uses "DataElement", the reference may be a property, a file, etc.
====


|xref:Entity[Entity] |Entity
|xref:EventElement[EventElement] a|
Event


====
Note: event elements are abstract.
====


|xref:File[File] |File
|xref:MultiLanguageProperty[MultiLanguageProperty] |Property with a value that can be provided in multiple languages
|xref:Operation[Operation] |Operation
|xref:Property[Property] |Property
|xref:Referable[Referable] a|
Referable


====
Note: referables are abstract, i.e. if a key uses "Referable", the reference may be an Asset Administration Shell, a property, etc.
====


|xref:Range[Range] |Range with min and max
|xref:ReferenceElement[ReferenceElement] |Reference
|xref:RelationshipElement[RelationshipElement] |Relationship
|xref:SubmodelElement[SubmodelElement] a|
Submodel element


====
Note: submodel elements are abstract, i.e. if a key uses "SubmodelElement", the reference may be a property, a submodel element list, an operation, etc.
====


|xref:SubmodelElementCollection[SubmodelElementCollection] |Struct of submodel elements
|xref:SubmodelElementList[SubmodelElementList] |List of submodel elements
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[GenericFragmentKeys]]GenericFragmentKeys
|Explanation: a|
Enumeration of different fragment key value types within a key


====
Note: not used as type but in constraints.
====


|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|FragmentReference |Bookmark or a similar local identifier of a subordinate part of a primary resource
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[AasIdentifiables]]AasIdentifiables
|Explanation: a|
Enumeration of different key value types within a key


====
Note: not used as type but in constraints.
====


|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xref:AssetAdministrationShell[AssetAdministrationShell] |Asset Administration Shell
|xref:ConceptDescription[ConceptDescription] |Concept description
|xref:Identifiable[Identifiable] a|
Identifiable


====
Note: Identifiables are abstract, i.e. if a key uses "Identifiable", the reference may be an Asset Administration Shell, a submodel, or a concept description.
====


|xref:Submodel[Submodel] |Submodel
|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[GenericGloballyIdentifiables]]GenericGloballyIdentifiables
|Explanation: |Enumeration of different key value types within a key
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|GlobalReference |Global reference
|===

===== Constraints

{aasd121}

{aasd122}

{aasd123}

{aasd124}

{aasd125}


====
Note: constraint AASd-125 ensures that the shortest path is used.
====


{aasd126}

{aasd127}


====
Note: which kind of fragments are supported depends on the content type and the specification of allowed fragment
identifiers for the corresponding resource referenced.
====



{aasd128}

In the following examples for valid und invalid model references and external references are given.
The notation follows the grammar as defined in section xref:#serialization-of-values-of-type-reference[].

[.underline]#Examples for valid references:#

*(Submodel)\https://example.com/aas/1/1/1234859590*

*(GlobalReference)\https://example.com/specification.html*

[.underline]#Examples for valid external references:#

*(GlobalReference)\https://example.com/ressource*

*(GlobalReference)0173-1#02-EXA123#001*

*(GlobalReference)\https://example.com/specification.html (FragmentReference)Hints*


====
Note: *(GlobalReference)\https://example.com/specification.html (FragmentReference)Hints* represents the path with fragment identifier \https://example.com/specification.html#Hints
====


[.underline]#Examples for valid model references:#

*(AssetAdministrationShell)\https://example.com/aas/1/0/12348*

*(Submodel)\https://example.com/aas/1/1/1234859590*

*(Submodel)\https://example.com/aas/1/1/1234859590, (File)Specification*

*(ConceptDescription)0173-1#02-BAA120#008*

*(Submodel)\https://example.com/aas/1/1/1234859590, (SubmodelElementList)Documents, (SubmodelElementCollection)0, (MultiLanguageProperty)Title*

*(Submodel)\https://example.com/aas/1/1/1234859590, (SubmodelElementCollection)Manual, (MultiLanguageProperty)Title*


====
Note: *(SubmodelElementCollection)0, (MultiLanguageProperty)Title* may be identical to 
*(SubmodelElementCollection)Manual, (MultiLanguageProperty)Title* semantically and content-wise. 
The difference is that more than one document is allowed in the first submodel and thus a submodel element list is defined: 
elements in a list are numbered. However, it is also possible to define a display name in this case. 
The display name of the SubmodelElementCollection should be the same in both bases, e.g. "Users Manual".
====


*(Submodel)\https://example.com/aas/1/1/1234859590, (File)Specification, (FragmentReference)Hints*


====
Note: assuming the file has the value using the absolute path \https://example.com/specification.html (and not a relative path), the first reference points to the same information as the global reference (GlobalReference\https://example.com/specification.html, (FragmentReference)Hints__.__
====


*(Submodel)\https://example.com/aas/1/1/1234859590, (Blob)Specification, (FragmentReference)Hints*



[.underline]#Examples for invalid model references:#

*(GlobalReference)\https://example.com/aas/1/1/1234859590*

This is an external reference but no model reference.

*(Property)0173-1#02-BAA120#008*

This reference does not start with the ID of an Identiable. Additionally the value is not valid idShort for a Property submodel element.

*(Submodel)\https://example.com/aas/1/1/1234859590, (EventElement)Event, (FragmentReference)Comment*

This model reference is invalid because fragment references so far are only defined for _File_ and _Blob_ submodel elements (see Constraint AASd-127, xref:AASd-127).

*(AssetAdministrationShell)\https://example.com/aas/1/0/12348, +
(Submodel)\https://example.com/aas/1/1/1234859590, (Property)Temperature*

This is not a valid model reference because _AssetAdministrationShell_ and _Submodel_ are both global identifiables.

==== Primitive and Simple Data Types

===== Predefined Simple Data Types

The metamodel of the Asset Administration Shell uses basic data types as defined in the link:https://www.w3.org/XML/Core/[XML Schema Definition] (XSD)footnote:[https://www.w3.org/XML/Core/, former https://www.w3.org/XML/Schema]. See Table 7 for an overview of the used types. Their definition is outside the scope of this document.

The meaning and format of xsd types is specified in https://www.w3.org/XML/Schema. The simple type "langString" is specified in the Resource Description Framework (RDF)footnote:[see: https://www.w3.org/TR/rdf11-concepts/].

See Clause 5.3.12.6 for constraints on types.

.Simple Data Types Used in Metamodel
[cols="10%,19%,38%,33%",options="header",]
|===
|Source |Basic Data Type |Value Range |Sample Values
|xsd |string |Character string (but not all Unicode character strings) |"Hello world", "Καλημέρα κόσμε", +
"ハローワールド""
|xsd |base64Binary |base64-encoded binary data |"a3Vtb3dhc2hlcmU="
|xsd |boolean |true, false |true, false
|xsd |dateType |Date and time with or without time zone |"2000-01-01T14:23:00", +
"2000-01-01T14:23:00.66372+14:00"footnote:[Corresponds to xs:dateTimeStamp in XML Schema 1.1]
|xsd |duration |Duration of time |"-P1Y2M3DT1H", +
"PT1H5M0S"
|rdf |langString |Strings with language tags a|
"Hello"@en, +
"Hallo"@de


====
Note: this is written in RDF/Turtle syntax, only "Hello" and "Hallo" are the actual values.
====


|===

===== Primitive Data Types

Table 8 lists the Primitives used in the metamodel. Primitive data types start with a capital letter.


====
Note: see Clause 5.3.12.6 for constraints on types.
====


.Primitive Data Types Used in Metamodel
[cols="13%,30%,57%",options="header",]
|===
|*Primitive* |*Definition* |*Value Examples*
|[[BlobType]]BlobType a|
_base64binary_

to represent file content (binaries and non-binaries)

a|
<?xml version="1.0" encoding="UTF-8"?>

<schema elementFormDefault="qualified" targetNamespace="http://www.admin-shell.io/aas/2/0" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:aas="http://www.admin-shell.io/aas/2/0" />

pass:[MZ_________ÿÿ__¸_______@___________________________________€_____º__´	Í!¸_LÍ!This program cannot be run in DOS mode.$_______PE__L___Rö\^________à_]

|[[ContentType]]ContentType a|
_string_ with max 100 and min 1 characters


====
Note: any content type as in RFC2046.
====


A media type (also MIME type and content type) […] is a two-part identifier for file formats and format contents transmitted on the Internet. The Internet Assigned Numbers Authority (IANA) is the official authority for the standardization and publication of these classifications. Media types were originally defined in Request for Comments 2045 in November 1996 as a part of MIME specification, for denoting type of email message content and attachments.footnote:[Wikipedia.org, date: 2018-04-09]

a|
application/pdf

image/jpeg

|[[Identifier]]Identifier |_string_ with max 2024 and min 1 characters a|
\https://cust/123456

0173-1#02-BAA120#008

|[[LabelType]]LabelType |_string_ with max 64 and min 1 characters |"ABC1234"
|[[LangStringSet]]LangStringSet a|
_Array of elements of type langString_


====
Note 1: langString is a RDF data type.
====



====
Note 2: a langString is a string value tagged with a language code.
====


Realization depends on the serialization rules for a technology.

a|
In xml:

<aas:langString lang="EN">This is a multi-language value in English</aas:langString>

<aas:langString lang="DE"> Das ist ein Multi-Language-Wert in Deutsch </aas:langString>

In rdf:

"This is a multi-language value in English"@en ;

"Das ist ein Multi-Language-Wert in Deutsch"@de

In JSON:

"description": [

  \{

      "language":"en", 

         "text": "This is a multi-language value in English."

  },

  \{

"language":"de",

"text": "Das ist ein Multi-Language-Wert in Deutsch." 

   }

]

|[[MessageTopicType]]MessageTopicType |_string_ with max 128 and min 1 characters |
|[[MultiLanguageNameType]]MultiLanguageNameType a|
_LangStringSet_

Each langString within the array of strings has a max of 1023 and a min of 1 characters (as for NameType).

|_See LangStringSet_
|[[MultiLanguageTextType]]MultiLanguageTextType a|
_LangStringSet_

Each string within langString has a max of 1,023 and min of 1 characters.

|_See LangStringSet_
|[[NameType]]NameType |_string_ with max 128 and min 1 characters |"ManufacturerPartId"
|[[PathType]]PathType a|
_Identifier_


====
Note: URL, based on [RFC-3986](https://www.rfc-editor.org/rfc/rfc3987) /[RFC-3987](https://www.rfc-editor.org/rfc/rfc3987), but more recently defined as living standard by WHATWG, as suggested by W3C: https://url.spec.whatwg.org/
====


a|
\./Specification.pdf

file:c:/local/Specification.pdf

\http://www.example.org

FTP://unicode.org


|[[RevisionType]]RevisionType a|
_string_ with max 4 and min 1 characters

following the following regular expression:

^([0-9]\|[1-9][0-9]*)$

a|
"0"

"7"

"567"

|[[QualifierType]]QualifierType |_NameType_ a|
"ExpressionSemantic" (as specified in DIN SPEC 92000:2019-09, see link:#bib16[[16\]])

"life cycle qual" (as specified in IEC 61360-7 - IEC/SC 3D - Common Data Dictionary (link:https://cdd.iec.ch/cdd/common/iec61360-7.nsf/SearchFrameset?OpenFrameSet[CDD - V2.0015.0004])

|[[VersionType]]VersionType a|
_string_ with max 4 and min 1 characters

following the following regular expression:

^([0-9]\|[1-9][0-9]*)$

a|
"1"

"9999"

|[[ValueDataType]]ValueDataType |_any xsd atomic type as specified via DataTypeDefXsd_ a|
"This is a string value"

10

1.5

2020-04-01

True

|===

===== Enumeration for Submodel Element Value Types

Enumerations are primitive data types. Most of the enumerations are defined in the context of their class. This clause defines enumerations for submodel element value typesfootnote:[E.g. Property/valueType].

The predefined types used to define the type of values of properties and other values use the names and the semantics of XML Schema Definition (XSD)footnote:[see https://www.w3.org/XML/Schema, https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes]. Additionally, the type "langString" with the semantics as defined in the Resource Description Framework (RDF)footnote:[see: https://www.w3.org/TR/rdf11-concepts/] is used. "langString" is a string value tagged with a language code.


====
Note 1: RDFfootnote:[See https://www.w3.org/TR/rdf11-concepts/#xsd-datatypes] recommends to not use the following xsd data types. That is why they are excluded from the allowed data types.
====


* XSD BuildIn List types are not supported (ENTITIES, IDREFS and NMTOKENS).
* XSD string BuildIn types are not supported (normalizedString, token, language, NCName, ENTITY, ID, IDREF).
* The following XSD primitive types are not supported: NOTATION, QName.


====
Note 2: the following RDF types are not supported: HTML and XMLLiteral.
====


.DefTypeDefRdf Enumeration
image::image53.png[]

The enumeration is derived from Figure 54.

.Data TypeDefXsd Enumeration
image::image54.png[]

Table 9 depicts example values and the value range of the different data type"

shows the data types which can be used for submodel element values. The data types are defined according to the W3C XML Schema (https://www.w3.org/TR/xmlschema-2/#built-in-datatypes and https://www.w3.org/TR/xmlschema-2/#built-in-derived). "Value Range" further explains the possible range of data values for this data type. The right column shows related examples for values of the corresponding data type.

.Data Types with Examplesfootnote:[See list of RDF-compatible XSD types with short description https://www.w3.org/TR/rdf11-concepts/#xsd-datatypes. Examples from https://openmanufacturingplatform.github.io/sds-bamm-aspect-meta-model/bamm-specification/v1.0.0/datatypes.html]
[cols="15%,22%,24%,39%",options="header",]
|===
| |Data Type |Value Range |Sample Values
|Core types |xs:string |Character string (but not all Unicode character strings) a|
"Hello world"

"Καλημέρα κόσμε"

"こんにちは世界"


| |xs:boolean |true, false |true, false
| |xs:decimal |Arbitrary-precision decimal numbers a|
-1.23

126789672374892739424.543233

+100000.00, 210

| |xs:integer |Arbitrary-size integer numbers a|
-1

0

126789675432332938792837429837429837429

+100000

|IEEE floating-point numbers |xs:double |64-bit floating point numbers incl. ±Inf, ±0, NaN a|
-1.0

+0.0

-0.0

234.567e8

-INF

NaN

| |xs:float |32-bit floating point numbers incl. ±Inf, ±0, NaN a|
-1.0

+0.0

-0.0

234.567e8

-INF

NaN

|Time and dates |xs:date |Dates (yyyy-mm-dd) with or without time zone a|
"2000-01-01"

"2000-01-01Z"

"2000-01-01+12:05"

| |xs:time |Times (hh:mm:ss.sss…​) with or without time zone a|
"14:23:00"

"14:23:00.527634Z"

"14:23:00+03:00"

| |xs:dateTime |Date and time with or without time zone a|
"2000-01-01T14:23:00"

"2000-01-01T14:23:00.66372+14:00"footnote:[Corresponds to xs:dateTimeStamp in XML Schema 1.1]

|Recurring and partial dates |xs:gYear |Gregorian calendar year a|
"2000"

"2000+03:00"

| |xs:gMonth |Gregorian calendar month a|
"--04"

"--04+03:00"

| |xs:gDay |Gregorian calendar day of the month a|
"---04"

"---04+03:00"

| |xs:gYearMonth |Gregorian calendar year and month a|
"2000-01"

"2000-01+03:00"

| |xs:gMonthDay |Gregorian calendar month and day a|
"--01-01"

"--01-01+03:00"

| |xs:duration |Duration of time a|
"P30D"

"-P1Y2M3DT1H", "PT1H5M0S"

|Limited-range integer numbers |xs:byte |-128…+127 (8 bit) a|
-1, 0

127

| |xs:short |-32768…+32767 (16 bit) a|
-1, 0

32767

| |xs:int |2147483648…+2147483647 (32 bit) a|
-1, 0

2147483647

| |xs:long |-9223372036854775808…+9223372036854775807 (64 bit) a|
-1

0, 9223372036854775807

| |xs:unsignedByte |0…255 (8 bit) a|
0

1

255

| |xs:unsignedShort |0…65535 (16 bit) a|
0

1

65535

| |xs:unsignedInt |0…4294967295 (32 bit) a|
0

1

4294967295

| |xs:unsignedLong |0…18446744073709551615 (64 bit) a|
0

1

18446744073709551615

| |xs:positiveInteger |Integer numbers >0 a|
1

7345683746578364857368475638745

| |xs:nonNegativeInteger |Integer numbers ≥0 a|
0

1

734568374657836485736847563

| |xs:negativeInteger |Integer numbers <0 a|
-1

- 23487263847628376482736487263

| |xs:nonPositiveInteger |Integer numbers ≤0 a|
-1

0

-938458374985739874987989873

|Encoded binary data |xs:hexBinary |Hex-encoded binary data |"6b756d6f77617368657265"
| |xs:base64Binary |Base64-encoded binary data |"a3Vtb3dhc2hlcmU="
|Miscellaneous types |xs:anyURI |Absolute or relative URIs and IRIs a|
\https://customer.com/demo/aas/1/1/1234859590

"urn:example:company:1.0.0"

| |rdf:langString |Strings with language tags a|
"Hello"@en

"Hallo"@de


====
Note: this is written in RDF/Turtle syntax, @en and de are the language tags.
====


|===

[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[DataTypeDefXsd]]DataTypeDefXsd
|Explanation: a|
Enumeration listing all xsd anySimpleTypes

For more details see https://www.w3.org/TR/rdf11-concepts/#xsd-datatypes

|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|xs:anyURI |see: https://www.w3.org/TR/xmlschema2/#anyURI
|xs:base64Binary |see: https://www.w3.org/TR/xmlschema2/#base64Binary
|xs:boolean |see https://www.w3.org/TR/xmlschema2/#boolean
|xs:byte |see https://www.w3.org/TR/xmlschema2/#byte
|xs:date |see https://www.w3.org/TR/xmlschema2/#date
|xs:dateTime |see https://www.w3.org/TR/xmlschema2/#dateTime
|xs:decimal |see https://www.w3.org/TR/xmlschema2/#decimal
|xs:double |see https://www.w3.org/TR/xmlschema2/#double
|xs:duration |see https://www.w3.org/TR/xmlschema2/#duration
|xs:float |see https://www.w3.org/TR/xmlschema2/#float
|xs:gDay |see https://www.w3.org/TR/xmlschema2/#gDay
|xs:gMonth |see https://www.w3.org/TR/xmlschema2/#gMonth
|xs:gMonthDay |see https://www.w3.org/TR/xmlschema2/#gMonthDay
|xs:gYear |see https://www.w3.org/TR/xmlschema2/#gYear
|xs:gYearMonth |see https://www.w3.org/TR/xmlschema2/#gYearMonth
|xs:hexBinary |see https://www.w3.org/TR/xmlschema2/#hexBinary
|xs:int |see https://www.w3.org/TR/xmlschema2/#int
|xs:integer |see https://www.w3.org/TR/xmlschema2/#integer
|xs:long |see https://www.w3.org/TR/xmlschema2/#long
|xs:negativeInteger |see https://www.w3.org/TR/xmlschema2/#negativeInteger
|xs:nonNegativeInteger |see: https://www.w3.org/TR/xmlschema2/#nonNegativeInteger
|xs:nonPositiveInteger |see: https://www.w3.org/TR/xmlschema2/#nonPositiveInteger
|xs:positiveInteger |see: https://www.w3.org/TR/xmlschema2/#positiveInteger
|xs:short |see: https://www.w3.org/TR/xmlschema2/#short
|xs:string |see: https://www.w3.org/TR/xmlschema-2/#string
|xs:time |see: https://www.w3.org/TR/xmlschema-2/#time
|xs:unsignedByte |see: https://www.w3.org/TR/xmlschema2/#unsignedShort
|xs:unsignedInt |see: https://www.w3.org/TR/xmlschema2/#unsignedInt
|xs:unsignedLong |see: https://www.w3.org/TR/xmlschema2/#unsignedLong
|xs:unsignedShort |see: https://www.w3.org/TR/xmlschema2/#unsignedShort
|xs:yearMonthDuration |see: https://www.w3.org/TR/xmlschema2/#yearMonthDuration
|===
[.table-with-appendix-table]
[cols="30%h,70%"]
|===
|Enumeration: |[[DataTypeDefRdf]]DataTypeDefRdf
|Explanation: |Enumeration listing all RDF types
|Set of: |--
|===
[cols="30%,70%"],options="header"]
|===
|Literal |Explanation
|rdf:langString |String with a language tag
|===

RDF requires IETF BCP 47footnote:[see https://tools.ietf.org/rfc/bcp/bcp47.txt] language tags. Simple two-letter language tags for locales like "de" conformant to ISO 639-1 are allowed, as well as language tags plus extension like "de-DE" for country code, dialect, etc. like in "en-US" for English (United States) or "en-GB" for English (United Kingdom). IETF language tags are referencing ISO 639, ISO 3166 and ISO 15924.

.Built-In Types of XML Schema Definition 1.0 (XSD)footnote:[Source: https://www.w3.org/TR/xmlschema-2/#built-in-primitive-datatypes]
image::image55.png[]

====  Constraints: Global Invariants

===== Introduction

This clause documents constraints that represent global invariants, i.e. constraints that cannot be assigned to a single class.

In contrast, a class invariant is a constraint that must be true for all instances of a class at any time. They are documented as part of the class specification.

===== Constraints for Referables and Identifiables

{aasd117}


====
Note: in other words (AASd-117), __idShort__ is mandatory for all __Referable__s except for referables being direct childs of __SubmodelElementList__s and for all __Identifiable__s.
====


{aasd120}

{aasd022}


====
Note: AASd-022 also means that __idShort__s of referables shall be matched sensitive to the case.
====


===== Constraints for Qualifiers

{aasd021}

{aasd119}

{aasd129}

===== Constraints for Extensions

{aasd077}

===== Constraints for Asset-Related Information

{aasd116}


====
Note: AASd-116 is important to enable a generic search across global and specific asset IDs.
====

====
Note: The semanticId of a SpecificAssetId with the predefined name "gloablAssetId" corresponds to the metamodel attribute "https://admin-shell-io/aas/3/1/AssetInformation/globalAssetId"
====

===== Constraints for Types

{aasd130}

Constraint AASd-130 ensures that encoding and interoperability between different serializations is possible. It corresponds to the restrictions as defined for the XML Schema 1.0footnote:[https://www.w3.org/TR/xml/#charsets].

== Data Specification Templates (normative)

include::IDTA-01001_DataSpecifications.adoc[]

== Mappings to Data Formats to Share I4.0-Compliant Information (normative)

=== General

It is crucial for Industry 4.0 applications to share information between different systems throughout the areas covered by the entire RAMI4.0 model link:#bib1[[1\]] link:#bib2[[2\]]. OPC UA is a frequently used format for information models in the domain of production operations, but there is a need for other formats for further areas and the relationships between them.

This document specifies the Asset Administration Shell in a technology-neutral format, UML. Different data formats are used or recommended to be used in the different life cycle phases of a productfootnote:[The word “data formats” is used as shortcut and includes the use of conceptual advantages such as information models, schemes, transmission protocols, etc.]. Serializations and mappings of the Asset Administration Shell are provided to cover the complete life cycle of each of these formats. Figure 57.

Table 10 explains the main purpose of each of the formats: OPC UA information modelsfootnote:[OPC UA Information Models should not be mixed up with the Client/Server or Pub/Sub Protocol of OPC UA. This would belong to the communication but not to the Asset Administration Shell representation layer.], AutomationML, XML, JSON, and RDF. The different purposes are visualized in Figure 57.

.Distinction of Different Data Formats for the Asset Administration Shell
[cols="21%,79%",options="header",]
|===
|Data format |Purpose / motivation
|XML, JSON |Serialization of information for the technical communication between phases
|RDF |Mapping of information to enable full use of the advantages of semantic technologies
|AutomationML |Sharing of type and instance information about assets, particularly during engineering; transfer of this information into the operational phase (cf. OPC UA and the corresponding mapping)
|OPC UA Information models |Access to all information of the administration data and sharing of live data within production operations; access for higher-level factory systems to this information
|===

.Graphic View on Exchange Data Formats for the Asset Administration Shellfootnote:[Only data formats considered in this document so far are mentioned in the figure.]
image::image58.jpeg[]


====
Note: the mapping specifications and schemata themselves are not part of the specification any longer but maintained open source. This eases usage of the specification and the different formats in open-source code projects.
====


===  General Rules

====  Introduction

There are some general rules that apply to all serializations or can be used in different serializations.

====  Encoding

Blobs require the following encoding: base64 string.

====  Serialization of Values of Type "Reference"

include::IDTA-01001_GrammarSerializationReference.adoc[] 


====  Semantic Identifiers for Metamodel and Data Specifications

include::IDTA-01001_GrammarSemanticIdsMetamodel.adoc[]


====  Embedded Data Specifications

include::IDTA-01001_EmbeddedDataSpecifications.adoc[]


===  XML

The metamodel of an Asset Administration Shell needs to be serialized for import and export scenarios. XML is a possible serialization format.

eXtensible Markup Language (XMLfootnote:[see: https://www.w3.org/TR/2008/REC-xml-20081126/]) is very well suited to derive information from an IT system, e.g. to process it manually and then feed it into another IT system. It meets the needs of the information sharing scenario defined in the leading picture in Clause 4.1. XML provides the possibilities of scheme definitions, which can be used to syntactically validate the represented information in each step.


====
Note 1: the xml schema (.xsd files) is maintained in the repository "aas-specs" of the github project admin-shell-io link:#bib51[[51\]]: aas-specs-3.0\schemas\xml
====



====
Note 2: the mapping rules of how to derive the xml schema from the technology-neutral metamodel as defined in this specification can be found here: aas-specs-3.0\schemas\xml\Readme.md#xml-mappingrules
====



====
Note 3: example files can be found here: aas-specs-3.0\schemas\xml\examples
====


===  JSON

JSONfootnote:[see: https://tools.ietf.org/html/rfc8259 or https://www.ecma-international.org/publications/standards/Ecma-404.htm] (JavaScript Object Notation) is a further serialization format that serializes the metamodel of an Asset Administration Shell for import and export scenarios.

Additionally, JSON format is used to describe the payload in the http/REST API for active Asset Administration Shells link:#bib37[[37\]].


====
Note 1: the JSON schema (.json files) is maintained in the repository "aas-specs" of the github project admin-shell-io link:#bib51[[51\]]: aas-specs-3.0\schemas\json
====



====
Note 2: the mapping rules of how to derive the JSON schema from the technology-neutral metamodel as defined in this specification can be found here: aas-specs-3.0\schemas\json\Readme.md#json-mappingrules
====



====
Note 3: example files can be found here: aas-specs-3.0\schemas\json\examples
====


===  RDF

The Resource Description Framework (RDF) link:#bib32[[32\]] is the recommended standard of the W3C to unambiguously model and present semantic data. RDF documents are structured in the form of triples, consisting of subjects, relations, and objects. The resulting model is often interpreted as a graph, with the subject and object elements as the nodes and the relations as the graph edges.

RDF is closely related to web standards, illustrated by the fact that all elements are encoded using (HTTP-)IRIs. As a common practice, the provision of additional information at the referenced location of an RDF entity directly allows the interlinking of entitiesfootnote:[Note: entity as a generic term and entity as a specific submodel element subtype need tobe distinugished.] based on the web. This process – following links in order to discover related information – is called dereferencing a resource and is supported by any browser or web client. Connecting distributed data sources through the web in the described manner is referred to by the term “Linked Data”. Connecting the available resources and capabilities of linked data with the expressiveness of the Asset Administration Shell is one motivation for the RDF serialization.

In addition, RDF is the basis of a wide range of logical inference and reasoning techniques. Vocabularies like RDF Schema (RDFS) and the Web Ontology Language (OWL) combine the graph-based syntax of RDF with formal definitions and axioms. This allows automated reasoners to understand the relation between entities to some extent and draw conclusions.

Combining both features, the RDF mapping of the Asset Administration Shell can provide the basis for complex queries and requests. SPARQL, the standard query language for the Semantic Web, can combine reasoning features with the integration of external data sources. In order to benefit of these abilities, the Asset Administration Shell requires a clear scheme of its RDF representation.


====
Note 1: the RDF scheme/OWL files (.ttl files) are maintained in the repository "aas-specs" of the github project admin-shell-io link:#bib51[[51\]]: aas-specs-3.0\schemas\rdf
====



====
Note 2: the mapping rules of how to derive the RDF schema from the technology-neutral metamodel as defined in this specification can be found here: aas-specs-3.0\schemas\rdf\Readme.md#rdf-mappingrules
====



====
Note 3: example files can be found here: aas-specs-3.0\schemas\rdf\examples
====


===  AutomationML

AutomationML (IEC 62714) is especially suited for serializing the import and export scenarios of the metamodel of an Asset Administration Shell in the engineering phase.

In general, the serialization approach is to map each object of the Asset Administration Shell metamodel to an AutomationML Role Class or to an AutomationML Role Class accompanied by an AutomationML Interface Class. This role class and (if applied) interface class also define the required attributes in AutomationML.

Asset Administration Shells themselves shall be modelled as AutomationML System Unit Classes or as Internal Elements within an Instance Hierarchy depending of the kind information of type and instance.

For the role classes and interface classes that are required for serialization, an AutomationML Role Class Library resp. an Interface Class Library are defined and provided to the public.

One of the goals is to ensure that the AutomationML model of the Asset Administration Shell can be used as a stand-alone AutomationML model, as well as in combination with existing AutomationML models such as the upcoming AutomationML Component Description. Therefore, the definition of the serialization approach defined in this clause is incorporated with the AutomationML definitions and applies the AutomationML technology definitions available on https://www.automationml.org/o.red.c/dateien.html.

link:#bib28[[28\]] is the AutomationML application recommendation for the Asset Administration Shell (AR AAS).


====
Note 1: the mapping of the Asset Administration Shell to AutomationML is carried out in a joint working group between AutomationML e.V. and Plattform Industrie 4.0.
====



====
Note 2: the resulting application recommendation (AR 004E) "Asset Administration Shell (AAS) Representation" link:#bib28[[28\]] can be found here: https://www.automationml.org/download-archive/, together with .aml files
====


===  OPC UA

OPC UA is suited for the operating phase of Asset Administration Shellsfootnote:[OPC UA is used for several purposes in the context of Industry 4.0. In this document, however, the focus is on Asset Administration Shell representation only.] and especially applicable in case of machine-to-machine communication. The information model link:#bib42[[42\]] is the basis for the definition of so-called OPC UA Information Models, or OPC UA Companion Specifications link:#bib43[[43\]].

Note1 : the mapping to the OPC UA are carried out in a joint working groupfootnote:[see: https://opcfoundation.org/collaboration/i4aas/] "I4AAS" between OPC Foundation, ZVEI and VDMA (https://opcfoundation.org/markets-collaboration/I4AAS/ link:#bib30[[30\]].


====
Note 2: the different versions of the OPC UA Companion Specification for I4AAS can be found here: https://reference.opcfoundation.org/%3cversion%3e/I4AAS/%3cversion%3e/docs/[https://reference.opcfoundation.org/<version>/I4AAS/<version>/docs/], e.g. https://reference.opcfoundation.org/v104/I4AAS/v100/docs/ for release 1.00 link:#bib41[[41\]].
====

== Summary and Outlook

This document has defined the metamodel for the structural viewpoint of the Asset Administration Shell using the technology-neutral modelling language UML.

Several serializations and mappings are offered for the Asset Administration Shell based on this specification:

* XML and JSON for Exchange between partners via the exchange format _.aasx,_
* RDF for reasoning,
* AutomationML for the engineering phase,
* OPC UA for the operation phase.

Additional parts of the document series cover (see link:#bib37[[37\]]):

* interfaces and APIs for accessing the information of Asset Administration Shells (access, modify, query, and execute information and active functionality), Part 2; the payload of these APIs is based on the definitions of the information model in this document, Part 1,
* predefined data specification templates (Part 3 series), for example for concept descriptions of properties conformant to IEC61360 (Part 3a),
* the infrastructure, which hosts and interconnects multiple Asset Administration Shells, implementing registry, discovery services, endpoint handling, and more,
* security aspects including access control, Part 4.


